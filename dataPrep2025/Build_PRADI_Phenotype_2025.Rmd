---
title: "PRADI Data Prep 2025"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: false
    theme: lumen
    css: "style.css"
---

Author: Mengna Zhang


*Last updated on:* `r Sys.Date()`


# Set Path

```{r set-path}
## directory: can extend to the main CNT folder
directory <- "/Users/"

## your own directory
my_directory <- paste0(directory, "mengnazhang/Desktop/")

## set PRADI path (the folder where PRADI raw files located)
pradi_directory <- paste0(my_directory, "ADSP_DataPrep_local/PRADI/Phenotype/2025/Raw/")

## output path
out_directory <- paste0(my_directory, "ADSP_DataPrep_local/PRADI/Phenotype/2025/Cleaned/")

## script path
script_directory <- paste0(my_directory, "ADSP_DataPrep_local/PRADI/Phenotype/2025/Scripts/")

## revised DD path
revisedDDpath <- paste0(out_directory,"colnamesPerSubdata.xlsx")
```

<br>

# Load Helper Scripts
```{r load-helper-scripts}
source("/Users/mengnazhang/Desktop/ADSP_DataPrep/dataPrep2025/helperScripts_PRADI.R")
# source(paste0(script_directory,"helperScripts_WRAP.R"))
```

<br>

# Load Packages
```{r laod-packages,message=FALSE,warning=FALSE}
require(dplyr)
require(readxl)
require(openxlsx)
require(stringr)
require(tidyr)
require(lubridate)
`%!in%` <- Negate(`%in%`)
```

<br>
<br>


# Sub Files Inspection

<!-- ## Save all sub file names -->
<!-- **Extract all file names** -->
<!-- ```{r engine='bash', comment=''} -->
<!-- mypath="/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Raw/" -->

<!-- ls ${mypath} | grep ".xlsx" > ${mypath}filelist.txt -->

<!-- wc -l ${mypath}filelist.txt ## 38 sub files in total -->
<!-- ``` -->


## Load All Subfiles

```{r load-all-files}

file_list <- paste0(out_directory,"filelist.txt")

## read all lines (file names) from the file
file_names <- readLines(file_list)

## loop over each file name
for (fname in file_names) {
  ## Extract the clean name by removing prefix and suffix
  clean_name <- sub("^PRADI_", "", fname)
  clean_name <- sub("_05122025\\.xlsx$", "", clean_name)
  
  ## read the Excel file and convert to data.frame
  data <- as.data.frame(read_excel(paste0(pradi_directory, fname),sheet = "Export Worksheet"))
  
  ## assign to a variable with the clean name in the global environment
  assign(clean_name, data, envir = .GlobalEnv)
  rm(data)
}

```

<br>
<br>

## Get Common Columns

```{r}
df_names <- ls()[sapply(mget(ls(), .GlobalEnv), is.data.frame)]

## extract the column names for each data frame
column_lists <- lapply(df_names, function(name) colnames(get(name)))

## find common columns across all data frames
common_cols <- Reduce(intersect, column_lists)

# Print the result
print(common_cols)
```

<br>
<br>

## Save all Colnames
```{r,eval=FALSE}
## This code only needs to be run once.
## It will generate an Excel file where each sheet contains the column names for its corresponding dataset.
## Then I will use this excel and fill the infor for each variable to generate the revise DD: 
# Create a new workbook
wb <- createWorkbook()

# For each data frame, add a sheet with its column names
# Loop through each data frame
for (df_name in df_names) {
  df <- get(df_name)  # get the actual data frame
  col_names_df <- data.frame(VarNames = colnames(df))  # create single-column df
  
  # Add sheet with df name (truncated to 31 characters max)
  sheet_name <- substr(df_name, 1, 31)
  addWorksheet(wb, sheetName = sheet_name)
  
  # Write the column names into the sheet
  writeData(wb, sheet = sheet_name, col_names_df)
}

# Save the workbook
## define the name and location of this file to save
saveWorkbook(wb, file = colnames_file, overwrite = TRUE)

```

<br>
<br>

# Variable Check Per File

## AAAD_GERIAT

```{r AAAD_GERIAT-1}
df <- AAAD_GERIAT

info(AAAD_GERIAT,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r AAAD_GERIAT-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r AAAD_GERIAT-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r AAAD_GERIAT-4}
dfDD <- read_excel(revisedDDpath, sheet = "AAAD_GERIAT")
```

<br>

### Handling Logical Variables

```{r AAAD_GERIAT-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 11 vars 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))

## NOTE: For the other 10 variables, the DD does not provide data type information, so Iâ€™m leaving them unspecified for now.

```


<br>

### Handling Date Variables

```{r AAAD_GERIAT-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r AAAD_GERIAT-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## 23 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
## ignore EXAMINER, as I assume we can have multiple examiners

```

<br>

### Handling Numeric Variables
```{r AAAD_GERIAT-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 27 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r AAAD_GERIAT-9}
AAAD_GERIAT <- df
```



<br>
<br>

## AAAD_MEDCON

```{r AAAD_MEDCON-1}
df <- AAAD_MEDCON

info(AAAD_MEDCON,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r AAAD_MEDCON-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r AAAD_MEDCON-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r AAAD_MEDCON-4}
dfDD <- read_excel(revisedDDpath, sheet = "AAAD_MEDCON")
```

<br>

### Handling Logical Variables

```{r AAAD_MEDCON-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 33 vars

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## "SEEN15" "SEEN18" "SEEN19" "SEEN20"

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 28 vars

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r AAAD_MEDCON-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "DATE_OF_ONSET"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## "REVIEW_DATE, ignore it, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r AAAD_MEDCON-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## 81 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## DOA_UNK, ignore, I have updated DD to "char"
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```

<br>

### Handling Numeric Variables
```{r AAAD_MEDCON-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 31 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP and IND
```

<br>

### Save Cleaned Data

```{r AAAD_MEDCON-9}
AAAD_MEDCON <- df
```




<br>
<br>

## AAAD_SOCIO_DEMO

```{r AAAD_SOCIO_DEMO-1}
df <- AAAD_SOCIO_DEMO

info(AAAD_SOCIO_DEMO,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r AAAD_SOCIO_DEMO-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r AAAD_SOCIO_DEMO-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r AAAD_SOCIO_DEMO-4}
dfDD <- read_excel(revisedDDpath, sheet = "AAAD_SOCIO_DEMO")
```

<br>

### Handling Logical Variables

```{r AAAD_SOCIO_DEMO-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 121

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## 55 vars

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)]
## [1] "REVIEW_DATE"

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 65 vars

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r AAAD_SOCIO_DEMO-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, can ignore, since it has been converted in last step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r AAAD_SOCIO_DEMO-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 89 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```


```{r AAAD_SOCIO_DEMO-8}
unique(df[["SDF8A"]]) ## DD: 8. Are you working now? Circle all that apply
unique(df[["SDF8B"]]) ## DD: If participant says NO, ask Why not? If any of the following SKIP TO #20

## NOTE: these two variables are good, as they being marked "Multiple" in the [Single, Multiple or Calculated Values] column of DD
```

<br>

### Handling Numeric Variables
```{r AAAD_SOCIO_DEMO-9}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 69 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r AAAD_SOCIO_DEMO-10}
AAAD_SOCIO_DEMO <- df
```


<br>
<br>

## AAAD_TRAILS

```{r AAAD_TRAILS-1}
df <- AAAD_TRAILS

info(AAAD_TRAILS,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r AAAD_TRAILS-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r AAAD_TRAILS-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r AAAD_TRAILS-4}
dfDD <- read_excel(revisedDDpath, sheet = "AAAD_TRAILS")
```

<br>

### Handling Logical Variables

```{r AAAD_TRAILS-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 3

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)]
## [1] "REVIEW_DATE"

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 2 vars

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r AAAD_TRAILS-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, can ignore, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r AAAD_TRAILS-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 8 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
```

<br>

### Handling Numeric Variables
```{r AAAD_TRAILS-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 23 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP and IND
## need to contact Mike about other variables: TIME_A, TIME_B, COR_B

```

<br>

### Save Cleaned Data

```{r AAAD_TRAILS-9}
AAAD_TRAILS <- df
```


<br>
<br>

## ALZ_B9_JUDGE_RC

```{r ALZ_B9_JUDGE_RC-1}
df <- ALZ_B9_JUDGE_RC

info(ALZ_B9_JUDGE_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_B9_JUDGE_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_B9_JUDGE_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r ALZ_B9_JUDGE_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_B9_JUDGE_RC")
```

<br>

### Handling Logical Variables

```{r ALZ_B9_JUDGE_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## MS_ALS_BEGIN_AGE

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"       "REVIEWER"     "MODE_ONSET6A"

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_B9_JUDGE_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_B9_JUDGE_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 17 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)

mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```

<br>

### Handling Numeric Variables
```{r ALZ_B9_JUDGE_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 62 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_B9_JUDGE_RC-9}
ALZ_B9_JUDGE_RC<- df
```


<br>
<br>

## ALZ_CLINICALSUM

```{r ALZ_CLINICALSUM-1}
df <- ALZ_CLINICALSUM

info(ALZ_CLINICALSUM,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_CLINICALSUM-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_CLINICALSUM-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r ALZ_CLINICALSUM-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_CLINICALSUM")
```

<br>

### Handling Logical Variables

```{r ALZ_CLINICALSUM-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## LAST_CONTACT_AGE

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## LAST_CONTACT_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## REFCTR

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_CLINICALSUM-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "DATE_OF_BIRTH" "VERIFY_DATE"   "FORM_DATE" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "LAST_CONTACT_DATE" can ignore LAST_CONTACT_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_CLINICALSUM-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 20 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## [1] "IMPRESSION"       "AD_CATEGORY"      "AD_HX_CATEGORY"   "UNCLEAR_CATEGORY"
## after checking the unique values of variables in the mismatchChrs_1, I believe that they all should be characters
## so I updated the DD for those variables (I changed their data type in DD and switch the values from "Valid Responses" and " Valid Responses Codes" columns)

mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## the descrption for variable FILLED_OUT_BY mentioned this is Dropdown style for people to select, so I belive that multiple values are fine
```

<br>

### Handling Numeric Variables
```{r ALZ_CLINICALSUM-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 15 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_CLINICALSUM-9}
ALZ_CLINICALSUM<- df
```


<br>
<br>

## ALZ_CSDD

```{r ALZ_CSDD-1}
df <- ALZ_CSDD

info(ALZ_CSDD,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_CSDD-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_CSDD-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r ALZ_CSDD-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_CSDD")
```

<br>

### Handling Logical Variables

```{r ALZ_CSDD-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 1

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_CSDD-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_CSDD-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 8 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
```

<br>

### Handling Numeric Variables
```{r ALZ_CSDD-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 32 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_CSDD-9}
ALZ_CSDD <- df
```


<br>
<br>

## ALZ_EXAM

```{r ALZ_EXAM-1}
df <- ALZ_EXAM

info(ALZ_EXAM,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_EXAM-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_EXAM-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_EXAM-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_EXAM")
```

<br>

### Handling Logical Variables

```{r ALZ_EXAM-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_EXAM-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "FORM_DATE"       "DATE_OF_BIRTH"   "NEURO_EXAM_DATE" "CLIN_EXAM_DATE" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_EXAM-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 66 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore NEURO_METHOD and FILLED_OUT_BY
```

<br>

### Handling Numeric Variables
```{r ALZ_EXAM-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 10 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_EXAM-9}
ALZ_EXAM <- df
```


<br>
<br>

## ALZ_GAI_SP

```{r ALZ_GAI_SP-1}
df <- ALZ_GAI_SP

info(ALZ_GAI_SP,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_GAI_SP-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_GAI_SP-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_GAI_SP-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_GAI_SP")
```

<br>

### Handling Logical Variables

```{r ALZ_GAI_SP-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR","REVIEWER")
convert2date <- c("REVIEW_DATE")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r ALZ_GAI_SP-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## "REVIEW_DATE, ignore it, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_GAI_SP-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## [1] "LSTUDY"   "DB_OWNER" "STUDY"    "SUBSTUDY" "CENTER"   "REFCTR"   "EXAMINER" "REVIEWER"

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
## ignore EXAMINER, as I assume we can have multiple examiners

```

<br>

### Handling Numeric Variables
```{r ALZ_GAI_SP-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 31 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

```

<br>

### Save Cleaned Data

```{r ALZ_GAI_SP-9}
ALZ_GAI_SP <- df
```


<br>
<br>

## ALZ_LOAD_COG

```{r ALZ_LOAD_COG-1}
df <- ALZ_LOAD_COG

info(ALZ_LOAD_COG,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_LOAD_COG-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_LOAD_COG-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_LOAD_COG-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_LOAD_COG")
```

<br>

### Handling Logical Variables

```{r ALZ_LOAD_COG-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR")
convert2num <-c("FRUITS")

## for others, they are missing info in DD, I will leave them for now

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2num] <- lapply(df[convert2chr], as.numeric)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_LOAD_COG-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Character Variables
```{r ALZ_LOAD_COG-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 9 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore INTERVIEWER
```

<br>

### Handling Numeric Variables
```{r ALZ_LOAD_COG-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 26 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_LOAD_COG-9}
ALZ_LOAD_COG <- df
```


<br>
<br>

## ALZ_NCRAD

```{r ALZ_NCRAD-1}
df <- ALZ_NCRAD

info(ALZ_NCRAD,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_NCRAD-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_NCRAD-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_NCRAD-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_NCRAD")
```

<br>

### Handling Logical Variables

```{r ALZ_NCRAD-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`,ignore.case = T)] ## 13 vars
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)] ## 5 vars

## convert
df[convert2num] <- lapply(df[convert2chr], as.numeric)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_NCRAD-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "FORM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_NCRAD-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 14 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore FILLED_OUT_BY
```

<br>

### Handling Numeric Variables
```{r ALZ_NCRAD-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 37 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_NCRAD-9}
ALZ_NCRAD <- df
```


<br>
<br>

## ALZ_NEURO_CDR

```{r ALZ_NEURO_CDR-1}
df <- ALZ_NEURO_CDR

info(ALZ_NEURO_CDR,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_NEURO_CDR-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_NEURO_CDR-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_NEURO_CDR-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_NEURO_CDR")
```

<br>

### Handling Logical Variables

```{r ALZ_NEURO_CDR-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r ALZ_NEURO_CDR-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_NEURO_CDR-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 10 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore FILLED_OUT_BY
```


<br>

### Handling Numeric Variables
```{r ALZ_NEURO_CDR-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 18 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_NEURO_CDR-9}
ALZ_NEURO_CDR <- df
```

<br>
<br>

## ALZ_NPIQ_CBRS

```{r ALZ_NPIQ_CBRS-1}
df <- ALZ_NPIQ_CBRS

info(ALZ_NPIQ_CBRS,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_NPIQ_CBRS-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_NPIQ_CBRS-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_NPIQ_CBRS-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_NPIQ_CBRS")
```

<br>

### Handling Logical Variables

```{r ALZ_NPIQ_CBRS-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_NPIQ_CBRS-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_NPIQ_CBRS-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 11 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore NPIQINF, since it can be multiple values as specified in the DD
```

<br>

### Handling Numeric Variables
```{r ALZ_NPIQ_CBRS-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 103 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_NPIQ_CBRS-9}
ALZ_NPIQ_CBRS <- df
```


<br>
<br>

## ALZ_RPFQ

```{r ALZ_RPFQ-1}
df <- ALZ_RPFQ

info(ALZ_RPFQ,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_RPFQ-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_RPFQ-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_RPFQ-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_RPFQ")
```

<br>

### Handling Logical Variables

```{r ALZ_RPFQ-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_RPFQ-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_RPFQ-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 17 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r ALZ_RPFQ-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 47 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_RPFQ-9}
ALZ_RPFQ <- df
```


<br>
<br>

## ALZ_SCREENING

```{r ALZ_SCREENING-1}
df <- ALZ_SCREENING

info(ALZ_SCREENING,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_SCREENING-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_SCREENING-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_SCREENING-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_SCREENING")
```

<br>

### Handling Logical Variables

```{r ALZ_SCREENING-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("DATE", dfDD$`Data Type`)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_SCREENING-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "FORM_DATE"      "DATE_OF_BIRTH"  "LUMBAR_DATE"    "BRAIN_MRI_DATE" "BRAIN_CT_DATE"  "EEG_DATE"       "PET_SP_DATE"  

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## "BRAIN_BIO_DATE", ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_SCREENING-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 31 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore FILLED_OUT_BY
```


<br>

### Handling Numeric Variables
```{r ALZ_SCREENING-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 10 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_SCREENING-9}
ALZ_SCREENING <- df
```


<br>
<br>

## ALZ_SCREENING_RC

```{r ALZ_SCREENING_RC-1}
df <- ALZ_SCREENING_RC

info(ALZ_SCREENING_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_SCREENING_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_SCREENING_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_SCREENING_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_SCREENING_RC")
```

<br>

### Handling Logical Variables

```{r ALZ_SCREENING_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,,ignore.case = T)] ## 6 vars
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,ignore.case = T)] ## 8 vars
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`,ignore.case = T)] ## 6 vars

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2num] <- lapply(df[convert2chr], as.numeric)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_SCREENING_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "LUMB_DT"       "BRNMRI_DT"     "BRNCT_DT"      "EEG_DT"        "PETSP_DT" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols)
# [1] "REVIEW_DATE"      "BRNBIO_DT"        "DATE_MMSE1"       "DATE_MOCA1"       "DATE_BROOKE1"     "DATE_CHIF1"      
# [7] "DATE_WORDLIST1"   "DATE_OTHER_TEST1"
## these variables have been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_SCREENING_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 29 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r ALZ_SCREENING_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 17 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_SCREENING_RC-9}
ALZ_SCREENING_RC <- df
```

<br>
<br>

## ALZ_STICK_D_RC

```{r ALZ_STICK_D_RC-1}
df <- ALZ_STICK_D_RC

info(ALZ_STICK_D_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_STICK_D_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_STICK_D_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r ALZ_STICK_D_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_STICK_D_RC")
```

<br>

### Handling Logical Variables

```{r ALZ_STICK_D_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## STATUS_DRSD

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date))

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_STICK_D_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_STICK_D_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 14 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r ALZ_STICK_D_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 29 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_STICK_D_RC-9}
ALZ_STICK_D_RC <- df
```

<br>
<br>

## B4_CDR_RC

```{r B4_CDR_RC-1}
df <- B4_CDR_RC

info(B4_CDR_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r B4_CDR_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r B4_CDR_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r B4_CDR_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "B4_CDR_RC")
```

<br>

### Handling Logical Variables

```{r B4_CDR_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r B4_CDR_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r B4_CDR_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 16 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r B4_CDR_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 19 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r B4_CDR_RC-9}
B4_CDR_RC <- df
```


<br>
<br>

## B5_NPIQ_RC

```{r B5_NPIQ_RC-1}
df <- B5_NPIQ_RC

info(B5_NPIQ_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r B5_NPIQ_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r B5_NPIQ_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r B5_NPIQ_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "B5_NPIQ_RC")
```

<br>

### Handling Logical Variables

```{r B5_NPIQ_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r B5_NPIQ_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r B5_NPIQ_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 10 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r B5_NPIQ_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 25 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r B5_NPIQ_RC-9}
B5_NPIQ_RC <- df
```


<br>
<br>

## B6_GDS_RC

```{r B6_GDS_RC-1}
df <- B6_GDS_RC

info(B6_GDS_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r B6_GDS_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r B6_GDS_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r B6_GDS_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "B6_GDS_RC")
```

<br>

### Handling Logical Variables

```{r B6_GDS_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("DATE", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r B6_GDS_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols)
# [1] "REVIEW_DATE", ignore it, this variables have been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r B6_GDS_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 9 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r B6_GDS_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 27 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r B6_GDS_RC-9}
B6_GDS_RC <- df
```

<br>
<br>

## B7_FAS_RC

```{r B7_FAS_RC-1}
df <- B7_FAS_RC

info(B7_FAS_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r B7_FAS_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r B7_FAS_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r B7_FAS_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "B7_FAS_RC")
```

<br>

### Handling Logical Variables

```{r B7_FAS_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r B7_FAS_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r B7_FAS_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 9 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r B7_FAS_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 21 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r B7_FAS_RC-9}
B7_FAS_RC<- df
```


<br>
<br>

## BCF_RECOG_RC

```{r BCF_RECOG_RC-1}
df <- BCF_RECOG_RC

info(BCF_RECOG_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r BCF_RECOG_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r BCF_RECOG_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r BCF_RECOG_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "BCF_RECOG_RC")
```

<br>

### Handling Logical Variables

```{r BCF_RECOG_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r BCF_RECOG_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r BCF_RECOG_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 9 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r BCF_RECOG_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 12 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r BCF_RECOG_RC-9}
BCF_RECOG_RC <- df
```

<br>
<br>

## BCFCD_RC

```{r BCFCD_RC-1}
df <- BCFCD_RC

info(BCFCD_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r BCFCD_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r BCFCD_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r BCFCD_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "BCFCD_RC")
```

<br>

### Handling Logical Variables

```{r BCFCD_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## "REFCTR" "REVIEWER" "TOTAL_SCORE_BENSON_DEL_STATUS"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r BCFCD_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r BCFCD_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 13 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r BCFCD_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 22 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r BCFCD_RC-9}
BCFCD_RC <- df
```

<br>
<br>

## BCFCI_RC

```{r BCFCI_RC-1}
df <- BCFCI_RC

info(BCFCI_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r BCFCI_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r BCFCI_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r BCFCI_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "BCFCI_RC")
```

<br>

### Handling Logical Variables

```{r BCFCI_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"  "REVIEWER"  "BCF_COPY_SCORE_STATUS"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r BCFCI_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, as it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r BCFCI_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 13 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r BCFCI_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 22 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r BCFCI_RC-9}
BCFCI_RC <- df
```


<br>
<br>

## BILINGUAL_SCALE_RC

```{r BILINGUAL_SCALE_RC-1}
df <- BILINGUAL_SCALE_RC

info(BILINGUAL_SCALE_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r BILINGUAL_SCALE_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r BILINGUAL_SCALE_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r BILINGUAL_SCALE_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "BILINGUAL_SCALE_RC")
```

<br>

### Handling Logical Variables

```{r BILINGUAL_SCALE_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 23 vars

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date))

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r BILINGUAL_SCALE_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r BILINGUAL_SCALE_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 33 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r BILINGUAL_SCALE_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 15 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r BILINGUAL_SCALE_RC-9}
BILINGUAL_SCALE_RC <- df
```

<br>
<br>

## CAT_FLUENCY_RC

```{r CAT_FLUENCY_RC-1}
df <- CAT_FLUENCY_RC

info(CAT_FLUENCY_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CAT_FLUENCY_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CAT_FLUENCY_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CAT_FLUENCY_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CAT_FLUENCY_RC")
```

<br>

### Handling Logical Variables

```{r CAT_FLUENCY_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CAT_FLUENCY_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CAT_FLUENCY_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 11 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CAT_FLUENCY_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 15 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CAT_FLUENCY_RC-9}
CAT_FLUENCY_RC <- df
```


<br>
<br>

## CERAD_DEL_RC

```{r CERAD_DEL_RC-1}
df <- CERAD_DEL_RC

info(CERAD_DEL_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CERAD_DEL_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CERAD_DEL_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CERAD_DEL_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CERAD_DEL_RC")
```

<br>

### Handling Logical Variables

```{r CERAD_DEL_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CERAD_DEL_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CERAD_DEL_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 13 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## [1] SCALES_CERADRECALL
## SCALES_CERADRECALL shows numeric in DD, but read in as character
## the reason it pops up is because they use "na" to represent the NAs
## I will correct it and convert it to numeric

df$SCALES_CERADRECALL[df$SCALES_CERADRECALL == "na"] <- NA
unique(df$SCALES_CERADRECALL)
df$SCALES_CERADRECALL <- as.numeric(df$SCALES_CERADRECALL)

mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CERAD_DEL_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 29 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CERAD_DEL_RC-9}
CERAD_DEL_RC <- df
```


<br>
<br>

## CERAD_IMM_RC

```{r CERAD_IMM_RC-1}
df <- CERAD_IMM_RC

info(CERAD_IMM_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CERAD_IMM_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CERAD_IMM_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CERAD_IMM_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CERAD_IMM_RC")
```

<br>

### Handling Logical Variables

```{r CERAD_IMM_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CERAD_IMM_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CERAD_IMM_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 17 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CERAD_IMM_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 68 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CERAD_IMM_RC-9}
CERAD_IMM_RC <- df
```


<br>
<br>

## CERAD_RECOG_RC

```{r CERAD_RECOG_RC-1}
df <- CERAD_RECOG_RC

info(CERAD_RECOG_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CERAD_RECOG_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CERAD_RECOG_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CERAD_RECOG_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CERAD_RECOG_RC")
```

<br>

### Handling Logical Variables

```{r CERAD_RECOG_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"  "REVIEWER" "WLRG_YES_STATUS" "WLRG_NO_STATUS" 

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CERAD_RECOG_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CERAD_RECOG_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 11 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CERAD_RECOG_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 34 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CERAD_RECOG_RC-9}
CERAD_RECOG_RC <- df
```


<br>
<br>

## CONSENSUS_DX

```{r CONSENSUS_DX-1}
df <- CONSENSUS_DX

info(CONSENSUS_DX,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CONSENSUS_DX-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CONSENSUS_DX-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CONSENSUS_DX-4}
dfDD <- read_excel(revisedDDpath, sheet = "CONSENSUS_DX")
```

<br>

### Handling Logical Variables

```{r CONSENSUS_DX-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] 
## 11 vars

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## OTHER_DATE1

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) 
## "REFCTR"  "CLINICAL_COMMENTS" "OTHER_TXT1"  "OTHER_TXT2"  "OTHER_TXT3" 

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CONSENSUS_DX-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "REVIEW_DATE"   "DATE_OF_BIRTH" "DATE_DX"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "OTHER_DATE1" can ignore OTHER_DATE1, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CONSENSUS_DX-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 17 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## Ignore REVIEWER, for others, waiting for confirmation from Mike, should I add those invalid values to the DD?
```

<br>

### Handling Numeric Variables
```{r CONSENSUS_DX-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 22 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CONSENSUS_DX-9}
CONSENSUS_DX <- df
```

<br>
<br>

## CRAFT_21_DEL_RC

```{r CRAFT_21_DEL_RC-1}
df <- CRAFT_21_DEL_RC

info(CRAFT_21_DEL_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CRAFT_21_DEL_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CRAFT_21_DEL_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CRAFT_21_DEL_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CRAFT_21_DEL_RC")
```

<br>

### Handling Logical Variables

```{r CRAFT_21_DEL_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"         "REVIEWER"       "CRAFTDVR_ENTRY"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CRAFT_21_DEL_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "CRAFTDTI"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CRAFT_21_DEL_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 10 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CRAFT_21_DEL_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 81 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CRAFT_21_DEL_RC-9}
CRAFT_21_DEL_RC <- df
```

<br>
<br>

## CRAFT_21_IMM_RC

```{r CRAFT_21_IMM_RC-1}
df <- CRAFT_21_IMM_RC

info(CRAFT_21_IMM_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CRAFT_21_IMM_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CRAFT_21_IMM_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CRAFT_21_IMM_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CRAFT_21_IMM_RC")
```

<br>

### Handling Logical Variables

```{r CRAFT_21_IMM_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## "REFCTR"         "REVIEWER"       "CRAFTVRS_ENTRY"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CRAFT_21_IMM_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "CRAFTVRS_TIME" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
## I will leave CRAFTVRS_TIME with format POSIXct since it contains the timestamp
## and I will convert the other two to date format
datecols <- setdiff(datecols, "CRAFTVRS_TIME")
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CRAFT_21_IMM_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 12 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CRAFT_21_IMM_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 82 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CRAFT_21_IMM_RC-9}
CRAFT_21_IMM_RC <- df
```


<br>
<br>

## MEDCON_RC

```{r MEDCON_RC-1 }
df <- MEDCON_RC

info(MEDCON_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MEDCON_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MEDCON_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MEDCON_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "MEDCON_RC")
```

<br>

### Handling Logical Variables

```{r MEDCON_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 7 vars

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,ignore.case = T)]
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2num] <- lapply(df[convert2num], as.numeric)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MEDCON_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "DATE_OF_ONSET"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MEDCON_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 69 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## 9 vars
## [1] "SEEN2"  "SEEN4"  "SEEN6"  "SEEN8"  "SEEN10" "SEEN12" "SEEN14" "SEEN16" "SEEN18"
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## convert mismatchChrs_1 vars to numeric
df[mismatchChrs_1] <- lapply(df[mismatchChrs_1], as.numeric)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r MEDCON_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 164 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MEDCON_RC-9}
MEDCON_RC <- df
```

<br>
<br>

## MEDICAL_HIST

```{r MEDICAL_HIST-1}
df <- MEDICAL_HIST

info(MEDICAL_HIST,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MEDICAL_HIST-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MEDICAL_HIST-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MEDICAL_HIST-4}
dfDD <- read_excel(revisedDDpath, sheet = "MEDICAL_HIST")
```

<br>

### Handling Logical Variables

```{r MEDICAL_HIST-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MEDICAL_HIST-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MEDICAL_HIST-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 40 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore CANCER_TYPE, as it is a multiple values variable
```


<br>

### Handling Numeric Variables
```{r MEDICAL_HIST-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 11 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MEDICAL_HIST-9}
MEDICAL_HIST <- df
```


<br>
<br>

## MINT_RC

```{r MINT_RC-1}
df <- MINT_RC

info(MINT_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MINT_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MINT_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MINT_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "MINT_RC")
```

<br>

### Handling Logical Variables

```{r MINT_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 115 vars 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)] ## 31 vars
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,,ignore.case = T)] ## 1 var
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`,,ignore.case = T)] ## 83 vars

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2num] <- lapply(df[convert2date], as.numeric)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MINT_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MINT_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 42 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r MINT_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 176 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MINT_RC-9}
MINT_RC <- df
```


<br>
<br>

## MINT_SP_RC

```{r MINT_SP_RC-1}
df <- MINT_SP_RC

info(MINT_SP_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MINT_SP_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MINT_SP_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MINT_SP_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "MINT_SP_RC")
```

<br>

### Handling Logical Variables

```{r MINT_SP_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)] ## 2 vars
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,,ignore.case = T)] ## 1 var

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MINT_SP_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MINT_SP_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 42 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r MINT_SP_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 176 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MINT_SP_RC-9}
MINT_SP_RC <- df
```

<br>
<br>

## MOCA_RC

```{r MOCA_RC-1}
df <- MOCA_RC

info(MOCA_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MOCA_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MOCA_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MOCA_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "MOCA_RC")
```

<br>

### Handling Logical Variables

```{r MOCA_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 17 vars

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MOCA_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"      "DATE_OF_BIRTH"  "MOCAORDT_ENTRY"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date","Date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MOCA_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 46 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0) 
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
```

<br>

### Handling Numeric Variables
```{r MOCA_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 90 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MOCA_RC-9}
MOCA_RC <- df
```

<br>
<br>

## NUMBER_SPAN_RC

```{r NUMBER_SPAN_RC-1}
df <- NUMBER_SPAN_RC

info(NUMBER_SPAN_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r NUMBER_SPAN_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r NUMBER_SPAN_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r NUMBER_SPAN_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "NUMBER_SPAN_RC")
```

<br>

### Handling Logical Variables

```{r NUMBER_SPAN_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r NUMBER_SPAN_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r NUMBER_SPAN_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 39 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```

<br>

### Handling Numeric Variables
```{r NUMBER_SPAN_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 43 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r NUMBER_SPAN_RC-9}
NUMBER_SPAN_RC <- df
```

<br>
<br>

# Duplicates Check

## Duplicates Detection

```{r dupCheck-2}
# Get names of all data frames in the environment
longDfwithDuplicates <- c()
otherwithDuplicates <- c()
index = 0

## following function will do:
## 1. filter out the okay cross-sectional datasets
## 2. for the rest: return the longitudinal/cross-sectional dataset names if duplicates got detected
for (df_name in df_names) {
  df <- get(df_name)
  
  ## filter out the okay cross-sectional datasets
  if (length(unique(df[["SYSIND"]])) == nrow(df)) {
    index = index + 1
    cat(index,
        "No duplicates found in cross-sectional dataset: ",
        df_name,
        "\n")
  } else{
    ## Check if columns ID and Visit exist (longitduinal data or not)
    if (all(c("SYSIND", "EXAM_DATE") %in% colnames(df))) {
      # Find duplicates using dplyr
      dup_rows <- df %>%
        dplyr::group_by(SYSIND, EXAM_DATE) %>%
        dplyr::filter(n() > 1) %>%
        dplyr::ungroup()
      
      # If any duplicates found, assign to new data frame with _Duplicates
      if (nrow(dup_rows) > 0) {
        longDfwithDuplicates <- c(longDfwithDuplicates, df_name)
      } else {
        index = index + 1
        cat(index,
            "No duplicates found in longitudinal dataset: ",
            df_name,
            "\n")
      }
    } else {
      otherwithDuplicates <- c(otherwithDuplicates, df_name)
    }
  }
}
```

<br>


```{r dupCheck-3}
## longidtudinal datatset with duplicate
longDfwithDuplicates
```

```{r dupCheck-4}
## otherwithDuplicates
## the following variables do not have EXAM_DATE but have other time variables
## so I will check duplicates one by one for them based on their unique time variables
otherwithDuplicates
```

```{r dupCheck-5}
## check duplicates for ALZ_CLINICALSUM
ALZ_CLINICALSUM %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## check duplicates for ALZ_EXAM
ALZ_EXAM %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## check duplicates for ALZ_LOAD_COG
ALZ_LOAD_COG %>%
  dplyr::group_by(SYSIND, INTERVIEW_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## check duplicates for ALZ_NCRAD
ALZ_NCRAD %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 2 rows

## ALZ_SCREENING
ALZ_SCREENING %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## CONSENSUS_DX
CONSENSUS_DX %>%
  dplyr::group_by(SYSIND, DATE_DX) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 211 rows

```


<br>
<br>

## Duplicates Handling Per Dataset

### ALZ_NPIQ_CBRS

```{r dupHandle-1}
cat("Before duplicates handling - SYSIND*EXAM_DATE is: ",dupFixCheck(ALZ_NPIQ_CBRS,"SYSIND","EXAM_DATE"),"\n")
```

```{r dupHandle-2}
info(ALZ_NPIQ_CBRS,"SYSIND")
```

```{r dupHandle-3}
## view the duplicates
ALZ_NPIQ_CBRS %>%
  dplyr::group_by(SYSIND, EXAM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup()
```

```{r dupHandle-4}
## after checking the duplicates, I decided to keep the second obs as it has less missingness
ALZ_NPIQ_CBRS <- ALZ_NPIQ_CBRS[ALZ_NPIQ_CBRS$SYSXM != "7540713", ]
```

```{r dupHandle-5}
info(ALZ_NPIQ_CBRS,"SYSIND")
```

```{r dupHandle-6}
cat("After duplicates handling - SYSIND*EXAM_DATE is: ",dupFixCheck(ALZ_NPIQ_CBRS,"SYSIND","EXAM_DATE"),"\n")
```

<br>
<br>

### ALZ_NCRAD

```{r dupHandle-7}
cat("Before duplicates handling - SYSIND*FORM_DATE is: ",dupFixCheck(ALZ_NCRAD,"SYSIND","FORM_DATE"),"\n")
```

```{r dupHandle-8}
info(ALZ_NCRAD,"SYSIND")
```

```{r dupHandle-9}
## view the duplicates
ALZ_NCRAD %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup()
```

```{r dupHandle-10}
## the duplicates are exactly same, so we can randomly drop one, I will drop the first observation
ALZ_NCRAD <- ALZ_NCRAD[ALZ_NCRAD$SYSXM != "7906253", ]
```

```{r dupHandle-11}
info(ALZ_NCRAD,"SYSIND")
```

```{r dupHandle-12}
cat("After duplicates handling - SYSIND*FORM_DATE is: ",dupFixCheck(ALZ_NCRAD,"SYSIND","FORM_DATE"),"\n")
```

<br>
<br>

### CONSENSUS_DX

```{r dupHandle-13}
cat("Before duplicates handling - SYSIND*DATE_DX is: ",dupFixCheck(CONSENSUS_DX,"SYSIND","DATE_DX"),"\n")
```

```{r dupHandle-14}
info(CONSENSUS_DX,"SYSIND")
```

```{r dupHandle-15}
## view the duplicates
dups_CONSENSUS_DX <- CONSENSUS_DX %>%
  dplyr::group_by(SYSIND, DATE_DX) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup()

info(dups_CONSENSUS_DX,"SYSIND") 
``` 

```{r dupHandle-16}
## some individuals have multiple CDX, and the RANK variable records the number of visits
## so I decided to use pivot_wider function to keep all the CDX values
## remove duplicates

IDcols <- c(names(CONSENSUS_DX)[1:16],"DATE_OF_BIRTH","DATE_DX",names(CONSENSUS_DX)[27:43])
IDcols

CONSENSUS_DX <- CONSENSUS_DX %>%
  pivot_wider(
    id_cols = all_of(IDcols),
    names_from = RANK,
    values_from = c(REVIEW_DATE, REVIEWER, RANK:WHO_DX,COMMENTS),
    names_sep = "_"
  )

```


```{r dupHandle-17}
info(CONSENSUS_DX,"SYSIND")
```

```{r dupHandle-18}
cat("After duplicates handling - SYSIND*DATE_DX is: ",dupFixCheck(CONSENSUS_DX,"SYSIND","DATE_DX"),"\n")
```

<br>
<br>


# Individuals Count

## Total Number of Individuals
```{r pp-count-1}
## get total number of unique inviduals
all_ids <- unlist(
  lapply(df_names, function(d) get(d)$SYSIND)
)

# Count unique SYSINDs
all_ids <- unique(all_ids)
length(all_ids) ## 1994 individuals
```

<br>

## Individual by Study Presence Check
```{r}
# Initialize a matrix with colored HTML symbols
presence_mat <- sapply(df_names, function(dfn) {
  df <- get(dfn)  # get the dataset by name
  present <- all_ids %in% df$SYSIND
  ifelse(
    present,
    '<span style="color:darkgreen; font-weight:bold;">âœ”</span>',
    '<span style="color:darkred; font-weight:bold;">âœ˜</span>'
  )
})

# Convert to data frame
presence_df <- data.frame(ID = all_ids, presence_mat, check.names = FALSE)

# columns to center (all except ID)
center_targets <- if (ncol(presence_df) > 1) 1:(ncol(presence_df) - 1) else integer(0)

DT::datatable(
  presence_df,
  escape = FALSE,
  rownames = FALSE,
  options = list(
    pageLength = 50,
    scrollX = TRUE,
    columnDefs = list(
      list(className = "dt-center", targets = center_targets) # 0-based indexing
    )
  )
)

```


<br>

## Individuals Missingness Per Study

```{r pp-count-2}
summary_df <- do.call(rbind, lapply(df_names, function(d) {
  df <- get(d)
  df_individuals <- unique(df$SYSIND)
  
  data.frame(
    dataset   = d,
    n_individuals = length(df_individuals),
    n_obs         = nrow(df),
    n_individials_missing   = length(setdiff(all_ids, df_individuals)),
    stringsAsFactors = FALSE
  )
}))

DT::datatable(summary_df)
```


<br>

```{r pp-count-3}
# Vectorized "filled" check per column
is_filled_col <- function(x) {
  if (is.factor(x)) x <- as.character(x)
  if (is.character(x)) {
    z <- trimws(x)
    !is.na(z) & nzchar(z)
  } else if (is.list(x)) {
    !vapply(x, function(el) is.null(el) || (length(el) == 0) || all(is.na(el)), logical(1))
  } else {
    !is.na(x)
  }
}

# Build presence table: drop common_cols (except keep SYSIND), keep SYSIND as-is
make_var_presence_table_filtered <- function(df, common_cols, id_col = "SYSIND") {
  stopifnot(is.data.frame(df))

  # Columns to keep: SYSIND + (all others not in common_cols)
  keep_cols <- c(id_col, setdiff(names(df), common_cols))
  keep_cols <- intersect(keep_cols, names(df))   # ensure existence
  df <- df[, keep_cols, drop = FALSE]

  # If SYSIND is missing after filtering, return empty structure (handled by caller)
  if (!id_col %in% names(df)) return(NULL)

  id_vals   <- df[[id_col]]
  other_cols <- setdiff(names(df), id_col)

  if (length(other_cols) == 0) {
    # Only SYSIND remains
    out <- setNames(data.frame(id_vals, check.names = FALSE), id_col)
    return(out)
  }

  # Logical filled matrix for other columns
  pres_list <- lapply(other_cols, function(v) is_filled_col(df[[v]]))
  pres_df   <- as.data.frame(pres_list, check.names = FALSE)
  names(pres_df) <- other_cols

  # Map to colored symbols
  pretty <- as.data.frame(
    lapply(pres_df, function(col)
      ifelse(col,
             '<span style="color:green; font-weight:bold;">âœ”</span>',
             '<span style="color:red; font-weight:bold;">âœ˜</span>')
    ),
    check.names = FALSE
  )

  # Bind SYSIND first (no data.table syntax)
  out <- cbind(setNames(data.frame(id_vals, check.names = FALSE), id_col), pretty)
  out
}

# Render one dataset tab (by name)
render_dataset_tab <- function(dfn, common_cols, id_col = "SYSIND") {
  # If object is missing, show a note
  if (!exists(dfn, envir = .GlobalEnv)) {
    note <- data.frame(Warning = sprintf("Object '%s' not found.", dfn))
    return(DT::datatable(note, rownames = FALSE, options = list(dom = "t")))
  }

  df <- get(dfn, envir = .GlobalEnv)

  if (!id_col %in% names(df)) {
    note <- data.frame(Warning = sprintf("Column '%s' not found in '%s'.", id_col, dfn))
    return(DT::datatable(note, rownames = FALSE, options = list(dom = "t")))
  }

  presence_df <- make_var_presence_table_filtered(df, common_cols, id_col = id_col)

  # Fallback if filtering removed everything (shouldnâ€™t, but safe)
  if (is.null(presence_df)) {
    note <- data.frame(Warning = sprintf("After filtering, no columns remain in '%s'.", dfn))
    return(DT::datatable(note, rownames = FALSE, options = list(dom = "t")))
  }

  DT::datatable(
    presence_df,
    escape = FALSE,
    rownames = FALSE,
    caption = htmltools::tags$caption(
      style = "caption-side: top; text-align: left; font-weight: bold; font-size: 110%;",
      paste0(
        "Dataset: ", dfn,
        "  (rows: ", nrow(df), ", cols shown: ", ncol(presence_df), ")"
      )
    ),
    options = list(
      pageLength = 50,
      scrollX = TRUE,
      deferRender = TRUE,
      columnDefs = list(
        # Center all columns except the first (SYSIND). DataTables uses 0-based indexes.
        list(className = "dt-center",
             targets = if (ncol(presence_df) > 1) 1:(ncol(presence_df) - 1) else integer(0))
      )
    )
  )
}

```



## Individual Missingness Per Variable Across Datasets {.tabset}

```{r, results='asis'}
for (dfn in df_names) {
  print(render_dataset_tab(dfn, common_cols, id_col = "SYSIND"))
}
```


<br>
<br>

# Merge Sub-Datasets

## Grouping Datasets
```{r}
cross_dfs<- c()
long_dfs_wEXAM_DATE <- c()
long_dfs_woEXAM_DATE <- c()

for (df_name in df_names) {
  df_obj <- get(df_name)  # get the dataframe
  if (nrow(df_obj) == length(unique(df_obj[["SYSIND"]]))) {
    cross_dfs <- c(cross_dfs, df_name)
  } else if ("EXAM_DATE" %in% names(df_obj)) {
    long_dfs_wEXAM_DATE <- c(long_dfs_wEXAM_DATE, df_name)
  } else{
    long_dfs_woEXAM_DATE <- c(long_dfs_woEXAM_DATE,df_name)
  }
}

cross_dfs
long_dfs_wEXAM_DATE
long_dfs_woEXAM_DATE
```


```{r}
dfwEXAM_DATE <- c()
dfwoEXAM_DATE <- c()

for (df_name in df_names) {
  df_obj <- get(df_name)  # get the dataframe
  
  if ("EXAM_DATE" %in% names(df_obj)) {
    dfwEXAM_DATE <- c(dfwEXAM_DATE, df_name)
  } else{
    dfwoEXAM_DATE <- c(dfwoEXAM_DATE,df_name)
  }
  
}

print(dfwEXAM_DATE)

print(dfwoEXAM_DATE)
```


<br>
<br>

## AGE_AT_EXAM Variable Explore

```{r}
## detect which dataset has AGE_AT_EXAM variable
index = 1

for (df_name in df_names) {
  df_obj <- get(df_name, inherits = TRUE)
  nms <- names(df_obj)

  has_age  <- "AGE_AT_EXAM" %in% nms
  has_date <- "EXAM_DATE"   %in% nms

  if (has_age && has_date) {
    cat(index, ":", df_name, ": both EXAM_DATE and AGE_AT_EXAM present\n")
  } else if (has_age && !has_date) {
    cat(index, ":", df_name, ": only AGE_AT_EXAM present\n")
  } else if (has_date && !has_age) {
    cat(index, ":", df_name, ": only EXAM_DATE present\n")
  } else {
    cat(index, ":", df_name, ": ============ none of them present ============\n")
  }

  index <- index + 1
}

```

<mark>**Findings:** AGE_AT_EXAM and EXAM_DATE variables are paired. If one presents, the other also presents.</mark>


```{r}
## group by SYSIND and AGE_AT_EXAM then check duplicates
index = 1
for (df_name in df_names) {
  df_obj <- get(df_name)  # get the dataframe
  if ("AGE_AT_EXAM" %in% names(df_obj)) {
    cat(index, " :", df_name, " : AGE_AT_EXAM present", "\n")
    
    dup_rows_AGE_AT_EXAM <- df_obj %>%
      dplyr::group_by(SYSIND, AGE_AT_EXAM) %>%
      dplyr::filter(n() > 1) %>%
      dplyr::ungroup()
    
    dup_rows_EXAM_DATE <- df_obj %>%
      dplyr::group_by(SYSIND, EXAM_DATE) %>%
      dplyr::filter(n() > 1) %>%
      dplyr::ungroup()
    
    if (nrow(dup_rows_AGE_AT_EXAM) > 0) {
      cat(index,
          " :",
          df_name,
          " : !!!duplicates present (checking by AGE_AT_EXAM )!!!",
          "\n")
    } else if (nrow(dup_rows_EXAM_DATE) > 0) {
      cat(index,
          " :",
          df_name,
          " : !!!duplicates present (checking by EXAM_DATE )!!!",
          "\n")
    } else{
      cat(index, " :", df_name, " : no duplicates found:)", "\n")
    }
    
  } else{
    cat(index, " :", df_name, "===============================================","\n")
  }
  index = index + 1
}
```


<mark>**Findings:** when mergeing, AGE_AT_EXAM can not be used as the key column, cause duplicates existed for some people with different AGE_AT_EXAM
after rounding up, those obs have same AGE_AT_EXAM values.</mark>


<br>
<br>

## Generate Visit Index Variable

```{r}
## for every individual, get all their date data
ppdat <- data.frame(SYSIND = numeric(0), EXAM_DATE = as.Date(character(0)))

## for dataset with EXAM_DATE, we just need to extract the relevant information and appending to the ppdat
for (df_name in dfwEXAM_DATE) {
  df_obj <- get(df_name)  # get the dataframe
  
  df_obj <- df_obj[,c("SYSIND","EXAM_DATE")]
  
  ppdat <- rbind(ppdat,df_obj)
}

ppdat <- ppdat[!duplicated(ppdat),]

## for dataset without EXAM_DATE, extract other data variables and appending to the ppdat

## ALZ_CLINICALSUM: has FORM_DATE
## ALZ_EXAM: has FORM_DATE
## ALZ_LOAD_COG: has INTERVIEW_DATE
## ALZ_NCRAD: has FORM_DATE
## ALZ_SCREENING: has FORM_DATE
## CONSENSUS_DX: DATE_DX

dfwFORM_DATE <- c("ALZ_CLINICALSUM","ALZ_EXAM","ALZ_NCRAD","ALZ_SCREENING")
for (df_name in dfwFORM_DATE) {
  df_obj <- get(df_name)  # get the dataframe
  
  df_obj <- df_obj[,c("SYSIND","FORM_DATE")]
  names(df_obj) <- c("SYSIND","EXAM_DATE")
  
  ppdat <- rbind(ppdat,df_obj)
}

ppdat <- ppdat[!duplicated(ppdat),]

df_obj <- ALZ_LOAD_COG
df_obj <- df_obj[,c("SYSIND","INTERVIEW_DATE")]
names(df_obj) <- c("SYSIND","EXAM_DATE")
ppdat <- rbind(ppdat,df_obj)
ppdat <- ppdat[!duplicated(ppdat),]

df_obj <- CONSENSUS_DX
df_obj <- df_obj[,c("SYSIND","DATE_DX")]
names(df_obj) <- c("SYSIND","EXAM_DATE")
ppdat <- rbind(ppdat,df_obj)
ppdat <- ppdat[!duplicated(ppdat),]

info(ppdat,"SYSIND") #obs:5204, cols:2, inds:1994

sorted_ppdat <- ppdat %>% arrange(SYSIND, EXAM_DATE)

## creating the Visit Index variable
## If a subjectâ€™s next exam is < 3 months after the last one, it stays in the same visit.
## If itâ€™s â‰¥ 3 months, it becomes the next visit.
## Starts at 1 for each subject.
sorted_ppdat2 <- sorted_ppdat %>%
  group_by(SYSIND) %>%
  mutate(
    new_visit = is.na(lag(EXAM_DATE)) |
      EXAM_DATE >= (lag(EXAM_DATE) %m+% months(6)),
    Visit_Index = cumsum(new_visit) ## start a new visit when the gap from the previous exam is â‰¥ 3 months
  ) %>%
  select(-new_visit) %>%
  ungroup()

## Visit summary
visit_summary <- sorted_ppdat2 %>%
  group_by(SYSIND) %>%
  summarise(
    total_visits = n_distinct(Visit_Index),
    total_obs    = n(),                 # how many raw rows for this person
    first_date   = min(EXAM_DATE, na.rm = TRUE),
    last_date    = max(EXAM_DATE, na.rm = TRUE),
    span_days    = as.integer(last_date - first_date)
  ) %>%
  arrange(desc(total_visits))

DT::datatable(visit_summary)

```

```{r}
## add Visit index back to each dataset

## for dataset with EXAM_DATE variable:
index = 1
for (df_name in dfwEXAM_DATE) {
  
  cat("======================================================================","\n")
  df_obj <- get(df_name)  # get the dataframe
  
  cat(index,": Currently processing dataset: ",df_name,"\n")
  cat("Dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  df_obj <- merge(df_obj,sorted_ppdat2,by=c("SYSIND","EXAM_DATE"))
  
  cat("After adding visit index, dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  ## change dataset name
  newdfname <- paste0("wVisitIndex_",df_name)
  assign(newdfname, df_obj)
  
  index = index + 1
}

```

```{r}
## Now add visit index to dataset with FORM_DATE
sorted_ppdat3 <- sorted_ppdat2
names(sorted_ppdat3)[names(sorted_ppdat3)=="EXAM_DATE"] <- "FORM_DATE"

for (df_name in dfwFORM_DATE) {
  cat("======================================================================","\n")
  df_obj <- get(df_name)  # get the dataframe
  
  cat(index,": Currently processing dataset: ",df_name,"\n")
  cat("Dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  df_obj <- merge(df_obj,sorted_ppdat3,by=c("SYSIND","FORM_DATE"))
  
  cat("After adding visit index, dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  ## change dataset name
  newdfname <- paste0("wVisitIndex_",df_name)
  assign(newdfname, df_obj)
  
  index = index + 1
}
```

```{r}
## Finally, we add visit index to the last two datasets: ALZ_LOAD_COG and CONSENSUS_DX

cat("======================================================================","\n")
df_obj <- ALZ_LOAD_COG  # get the dataframe
df_name <- "ALZ_LOAD_COG"
cat(index,": Currently processing dataset: ",df_name,"\n")
cat("Dataset dimension: ","\n")
info(df_obj,"SYSIND")
df_obj <- merge(df_obj,sorted_ppdat2,by.x=c("SYSIND","INTERVIEW_DATE"),by.y = c("SYSIND","EXAM_DATE"))
cat("After adding visit index, dataset dimension: ","\n")
info(df_obj,"SYSIND")
## change dataset name
newdfname <- paste0("wVisitIndex_",df_name)
assign(newdfname, df_obj)
index = index + 1

cat("======================================================================","\n")
df_obj <- CONSENSUS_DX  # get the dataframe
df_name <- "CONSENSUS_DX"
cat(index,": Currently processing dataset: ",df_name,"\n")
cat("Dataset dimension: ","\n")
info(df_obj,"SYSIND")
df_obj <- merge(df_obj,sorted_ppdat2,by.x=c("SYSIND","DATE_DX"),by.y = c("SYSIND","EXAM_DATE"))
cat("After adding visit index, dataset dimension: ","\n")
info(df_obj,"SYSIND")
## change dataset name
newdfname <- paste0("wVisitIndex_",df_name)
assign(newdfname, df_obj)

```


## Merge All Datasets

```{r}
## since there are a lot of columns for individuals identifiers, instead of merging the dataset by all of these, I decided to taking them out and merge it back to the very end

colsWfixedValues <- c("SYSGP","SYSGPSTUDY","SYSINDGP","CGI_ORDER","GPS_ORDER","STDCGI_ORDER","LSTUDY","DB_OWNER","STUDY","SUBSTUDY","CENTER","GP","IND","REFCTR","DATE_OF_BIRTH") ## 15 vars

df_names <- ls(pattern = "^wVisitIndex_")
length(df_names)

## this dataset will stored all those identifer values which will be merged to the final dataset at the very end
colsWfixedValuesDF <- wVisitIndex_AAAD_GERIAT[,colsWfixedValues]

index = 1
for (df_name in df_names) {
  cat("======================================================================","\n")
  df_obj <- get(df_name)
  cat(index,": Currently processing dataset: ",df_name,"\n")
  cat("Dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  colsWfixedValuesDF <- rbind(colsWfixedValuesDF,df_obj[,colsWfixedValues])
  
  ## drop columns of colsWfixedValues
  df_obj <- df_obj[, setdiff(names(df_obj), colsWfixedValues), drop = FALSE]
  
  cat("After removing indetifer columns, dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  assign(df_name, df_obj)
  index = index + 1
}

colsWfixedValuesDF <- colsWfixedValuesDF[!duplicated(colsWfixedValuesDF),]
info(colsWfixedValuesDF,"SYSINDGP") #obs:1994, cols:15, inds:1994 

```


```{r,eval=FALSE}
## Now we can merge all datasets!!
mergedDF <- get(df_names[1])
tc <- c("EXAM_DATE","SYSXM","EXAMINER","AGE_AT_EXAM")
idx <- match(tc, colnames(mergedDF))
colnames(mergedDF)[idx] <- paste0(tc, "_", df_names[1])

for (i in 2:length(df_names)) { 
  mergedDF <- merge_with_info("mergedDF", df_names[i], merge_cols = c("SYSIND","Visit_Index"), info_col = "SYSIND") 
}

```


```{r}
## merge with 
```

