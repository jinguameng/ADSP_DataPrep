---
title: "PRADI Data Prep 2025"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: false
    theme: lumen
    css: "style.css"
---

Author: Mengna Zhang


*Last updated on:* `r Sys.Date()`


# Set Path

```{r}
#directory
directory <- "/Users/mengnazhang/Desktop/"
my_directory <- paste0(directory, "ADSP_DataPrep_local/PRADI/Phenotype/2025/Raw/")

## colnames excel file location
colnames_file <- "/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx"
```

<br>

# Load Packages
```{r,message=FALSE,warning=FALSE}
require(dplyr)
require(readxl)
require(openxlsx)
require(stringr)
```

<br>

# Load Helper Scripts
```{r}
source("/Users/mengnazhang/Desktop/ADSP_DataPrep/dataPrep2025/helperScripts.R")
```

<br>
<br>


# Sub Files Inspection

## Save all sub file names
**Extract all file names**
```{r engine='bash', comment=''}
mypath="/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Raw/"

ls ${mypath} | grep ".xlsx" > ${mypath}filelist.txt

wc -l ${mypath}filelist.txt ## 38 sub files in total
```

<br>
<br>

## Load All Subfiles

```{r}

file_list <- paste0(my_directory,"filelist.txt")

## read all lines (file names) from the file
file_names <- readLines(file_list)

## loop over each file name
for (fname in file_names) {
  ## Extract the clean name by removing prefix and suffix
  clean_name <- sub("^PRADI_", "", fname)
  clean_name <- sub("_05122025\\.xlsx$", "", clean_name)
  
  ## read the Excel file and convert to data.frame
  data <- as.data.frame(read_excel(paste0(my_directory, fname),sheet = "Export Worksheet"))
  
  ## assign to a variable with the clean name in the global environment
  assign(clean_name, data, envir = .GlobalEnv)
  rm(data)
}

```

<br>
<br>

## Get Common Columns

```{r}
df_names <- ls()[sapply(mget(ls(), .GlobalEnv), is.data.frame)]

## extract the column names for each data frame
column_lists <- lapply(df_names, function(name) colnames(get(name)))

## find common columns across all data frames
common_cols <- Reduce(intersect, column_lists)

# Print the result
print(common_cols)
```

<br>
<br>

## Save all Colnames
```{r,eval=FALSE}
## this code only need to be run once
# Create a new workbook
wb <- createWorkbook()

# For each data frame, add a sheet with its column names
# Loop through each data frame
for (df_name in df_names) {
  df <- get(df_name)  # get the actual data frame
  col_names_df <- data.frame(VarNames = colnames(df))  # create single-column df

  # Add sheet with df name (truncated to 31 characters max)
  sheet_name <- substr(df_name, 1, 31)
  addWorksheet(wb, sheetName = sheet_name)

  # Write the column names into the sheet
  writeData(wb, sheet = sheet_name, col_names_df)
}

# Save the workbook
saveWorkbook(wb, file = colnames_file, overwrite = TRUE)

```

<br>
<br>

# Variable Check Per File

## AAAD_GERIAT

```{r}
df <- AAAD_GERIAT

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r}
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "AAAD_GERIAT")
```

<br>

### Handling Logical Variables

```{r}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 11 vars 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## 23 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
## ignore EXAMINER, as I assume we can have multiple examiners

```

<br>

### Handling Numeric Variables
```{r}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 27 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r}
clean_AAAD_GERIAT <- df
```



<br>
<br>

## AAAD_MEDCON

```{r}
df <- AAAD_MEDCON

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r}
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "AAAD_MEDCON")
```

<br>

### Handling Logical Variables

```{r}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 33 vars

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## "SEEN15" "SEEN18" "SEEN19" "SEEN20"

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 28 vars

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "DATE_OF_ONSET"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## "REVIEW_DATE, ignore it, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## 81 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## DOA_UNK, ignore, I have updated DD to "char"
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```

<br>

### Handling Numeric Variables
```{r}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 31 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP and IND
```

<br>

### Save Cleaned Data

```{r}
clean_AAAD_MEDCON <- df
```




<br>
<br>

## AAAD_SOCIO_DEMO

```{r}
df <- AAAD_SOCIO_DEMO

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r}
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "AAAD_SOCIO_DEMO")
```

<br>

### Handling Logical Variables

```{r}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 121

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## 55 vars

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)]
## [1] "REVIEW_DATE"

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 65 vars

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, can ignore, since it has been converted in last step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 89 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```


```{r}
unique(df[["SDF8A"]]) ## DD: 8. Are you working now? Circle all that apply
unique(df[["SDF8B"]]) ## DD: If participant says NO, ask Why not? If any of the following SKIP TO #20

## NOTE: these two variables are good, as they being marked "Multiple" in the [Single, Multiple or Calculated Values] column of DD
```

<br>

### Handling Numeric Variables
```{r}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 69 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r}
clean_AAAD_SOCIO_DEMO <- df
```


<br>
<br>

## AAAD_TRAILS

```{r}
df <- AAAD_TRAILS

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r}
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "AAAD_TRAILS")
```

<br>

### Handling Logical Variables

```{r}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 3

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)]
## [1] "REVIEW_DATE"

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 2 vars

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, can ignore, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 8 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## [1] "TIME_AMISS" "ERR_AMISS"  "COR_AMISS"  "TIME_BMISS" "ERR_BMISS"  "COR_BMISS"

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## as those variables in mismatchChrs_2 all have numeric values as valid responses, I think they should be categorized as numeric variables.
## so I decided to update the DD for those variables

## reload the DD
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "AAAD_TRAILS")
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]
mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
```

<br>

### Handling Numeric Variables
```{r}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 23 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP and IND
## need to contact Mike about other variables: TIME_A, TIME_B, COR_B

```

<br>

### Save Cleaned Data

```{r}
clean_AAAD_TRAILS <- df
```


<br>
<br>

## ALZ_B9_JUDGE_RC

```{r}
df <- ALZ_B9_JUDGE_RC

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r}
## I dont see the DD for this dataset
```


<br>
<br>

## ALZ_CLINICALSUM

```{r}
df <- ALZ_CLINICALSUM

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r}
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "ALZ_CLINICALSUM")
```

<br>

### Handling Logical Variables

```{r}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## [1] "REFCTR"            "LAST_CONTACT_DATE" "LAST_CONTACT_AGE" 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## LAST_CONTACT_AGE

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## LAST_CONTACT_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## REFCTR

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "DATE_OF_BIRTH" "VERIFY_DATE"   "FORM_DATE" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "LAST_CONTACT_DATE" can ignore LAST_CONTACT_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 20 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## [1] "IMPRESSION"       "AD_CATEGORY"      "AD_HX_CATEGORY"   "UNCLEAR_CATEGORY"
## after checking the unique values of variables in the mismatchChrs_1, I believe that they all should be characters
## so I updated the DD for those variables (I changed their data type in DD and switch the values from "Valid Responses" and " Valid Responses Codes" columns)

mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## the descrption for variable FILLED_OUT_BY mentioned this is Dropdown style for people to select, so I belive that multiple values are fine
```

<br>

### Handling Numeric Variables
```{r}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 15 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r}
clean_ALZ_CLINICALSUM<- df
```


<br>
<br>

## ALZ_CSDD

```{r}
df <- ALZ_CSDD

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r}
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "ALZ_CSDD")
```

<br>

### Handling Logical Variables

```{r}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 1

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 8 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
```

<br>

### Handling Numeric Variables
```{r}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 32 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r}
clean_ALZ_CSDD <- df
```


<br>
<br>

## ALZ_EXAM

```{r}
df <- ALZ_EXAM

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r}
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "ALZ_EXAM")
```

<br>

### Handling Logical Variables

```{r}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## REFCTR

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "FORM_DATE"       "DATE_OF_BIRTH"   "NEURO_EXAM_DATE" "CLIN_EXAM_DATE" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 66 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore NEURO_METHOD and FILLED_OUT_BY
```

<br>

### Handling Numeric Variables
```{r}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 10 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r}
clean_ALZ_EXAM <- df
```


<br>
<br>

## ALZ_GAI_SP

```{r}
df <- ALZ_GAI_SP

## extract all the unique data types
unique(sapply(df, class))
```

```{r,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r}
dfDD <- read_excel("/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Clean/colnamesPerSubdata.xlsx", sheet = "ALZ_GAI_SP")
```

<br>

### Handling Logical Variables

```{r}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## [1] "REFCTR"      "REVIEW_DATE" "REVIEWER" 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR","REVIEWER")
convert2date <- c("REVIEW_DATE")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## "REVIEW_DATE, ignore it, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## [1] "LSTUDY"   "DB_OWNER" "STUDY"    "SUBSTUDY" "CENTER"   "REFCTR"   "EXAMINER" "REVIEWER"

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
## ignore EXAMINER, as I assume we can have multiple examiners

```

<br>

### Handling Numeric Variables
```{r}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 31 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

```

<br>

### Save Cleaned Data

```{r}
clean_ALZ_GAI_SP <- df
```



