---
title: "PRADI Data Prep 2025"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: false
    theme: lumen
---

Author: Mengna Zhang


*Last updated on:* `r Sys.Date()`


# Set Path

```{r set-path}
## directory: can extend to the main CNT folder
directory <- "/Users/"

## your own directory
my_directory <- paste0(directory, "mengnazhang/Desktop/")

## set PRADI path (the folder where PRADI raw files located)
pradi_directory <- paste0(my_directory, "ADSP_DataPrep_local/PRADI/Phenotype/2025/Raw/")

## output path
out_directory <- paste0(my_directory, "ADSP_DataPrep_local/PRADI/Phenotype/2025/Cleaned/")

## script path
script_directory <- paste0(my_directory, "ADSP_DataPrep_local/PRADI/Phenotype/2025/Scripts/")

## revised DD path
revisedDDpath <- paste0(out_directory,"colnamesPerSubdata.xlsx")

## file list
file_list <- paste0(out_directory,"filelist.txt")
```

<br>

# Load Helper Scripts
```{r load-helper-scripts}
source(paste0(script_directory,"helperScripts_PRADI.R"))
```

<br>

# Load Packages
```{r laod-packages,message=FALSE,warning=FALSE}
require(dplyr)
require(readxl)
require(openxlsx)
require(stringr)
require(tidyr)
require(lubridate)
require(ggplot2)
`%!in%` <- Negate(`%in%`)
```

<br>
<br>


# Sub Files Inspection


## Save all sub file names

<mark>This is the code I used to save all the raw file names into a txt file. You dont need to run it. I have provided the file in the one-drive.</mark>

**Extract all file names**
```{r engine='bash', comment='',eval=F}
## mypath="/Users/mengnazhang/Desktop/ADSP_DataPrep_local/PRADI/Phenotype/2025/Raw/"

## ls ${mypath} | grep ".xlsx" > ${mypath}filelist.txt

## wc -l ${mypath}filelist.txt ## 38 sub files in total
```


## Load All Subfiles

```{r load-all-files}
## read all lines (file names) from the file
file_names <- readLines(file_list)

## loop over each file name
for (fname in file_names) {
  ## Extract the clean name by removing prefix and suffix
  clean_name <- sub("^PRADI_", "", fname)
  clean_name <- sub("_05122025\\.xlsx$", "", clean_name)
  
  ## read the Excel file and convert to data.frame
  data <- as.data.frame(read_excel(paste0(pradi_directory, fname),sheet = "Export Worksheet"))
  
  ## assign to a variable with the clean name in the global environment
  assign(clean_name, data, envir = .GlobalEnv)
  rm(data)
}

```

<br>
<br>

## Get Common Columns

```{r}
df_names <- ls()[sapply(mget(ls(), .GlobalEnv), is.data.frame)]

## extract the column names for each data frame
column_lists <- lapply(df_names, function(name) colnames(get(name)))

## find common columns across all data frames
common_cols <- Reduce(intersect, column_lists)

# Print the result
print(common_cols)
```

<br>
<br>

## Save all Colnames

<mark>The commented code below generates an empty DD file based on the dataset currently loaded in the workspace.
Since the raw DD from PRADI is disorganized and difficult to read, I decided to create a new DD and manually fill in all the information extracted from the original.
You don’t need to run the code below unless you want to generate another one yourself.</mark>

```{r,eval=FALSE}
# ## This code only needs to be run once.
# ## It will generate an Excel file where each sheet contains the column names for its corresponding dataset.
# ## Then I will use this excel and fill the infor for each variable to generate the revise DD:
# # Create a new workbook
# wb <- createWorkbook()
# 
# # For each data frame, add a sheet with its column names
# # Loop through each data frame
# for (df_name in df_names) {
#   df <- get(df_name)  # get the actual data frame
#   col_names_df <- data.frame(VarNames = colnames(df))  # create single-column df
# 
#   # Add sheet with df name (truncated to 31 characters max)
#   sheet_name <- substr(df_name, 1, 31)
#   addWorksheet(wb, sheetName = sheet_name)
# 
#   # Write the column names into the sheet
#   writeData(wb, sheet = sheet_name, col_names_df)
# }
# 
# # Save the workbook
# ## define the name and location of this file to save
# saveWorkbook(wb, file = colnames_file, overwrite = TRUE)

```

<br>
<br>

# Variable Check Per File

## AAAD_GERIAT
Geriatric Depression Scale

```{r AAAD_GERIAT-1}
df <- AAAD_GERIAT

info(AAAD_GERIAT,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r AAAD_GERIAT-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r AAAD_GERIAT-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r AAAD_GERIAT-4}
dfDD <- read_excel(revisedDDpath, sheet = "AAAD_GERIAT")
```

<br>

### Handling Logical Variables

```{r AAAD_GERIAT-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 11 vars 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))

## NOTE: For the other 10 variables, the DD does not provide data type information, so I’m leaving them unspecified for now.

```


<br>

### Handling Date Variables

```{r AAAD_GERIAT-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r AAAD_GERIAT-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## 23 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
## ignore EXAMINER, as I assume we can have multiple examiners

```

<br>

### Handling Numeric Variables
```{r AAAD_GERIAT-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 27 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r AAAD_GERIAT-9}
AAAD_GERIAT <- df
```



<br>
<br>

## AAAD_MEDCON
Medical Condition

```{r AAAD_MEDCON-1}
df <- AAAD_MEDCON

info(AAAD_MEDCON,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r AAAD_MEDCON-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r AAAD_MEDCON-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r AAAD_MEDCON-4}
dfDD <- read_excel(revisedDDpath, sheet = "AAAD_MEDCON")
```

<br>

### Handling Logical Variables

```{r AAAD_MEDCON-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 33 vars

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## "SEEN15" "SEEN18" "SEEN19" "SEEN20"

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 28 vars

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r AAAD_MEDCON-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "DATE_OF_ONSET"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## "REVIEW_DATE, ignore it, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r AAAD_MEDCON-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## 81 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## DOA_UNK, ignore, I have updated DD to "char"
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```

<br>

### Handling Numeric Variables
```{r AAAD_MEDCON-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 31 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP and IND
```

<br>

### Save Cleaned Data

```{r AAAD_MEDCON-9}
AAAD_MEDCON <- df
```




<br>
<br>

## AAAD_SOCIO_DEMO
Socio-Demographic Form

```{r AAAD_SOCIO_DEMO-1}
df <- AAAD_SOCIO_DEMO

info(AAAD_SOCIO_DEMO,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r AAAD_SOCIO_DEMO-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r AAAD_SOCIO_DEMO-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r AAAD_SOCIO_DEMO-4}
dfDD <- read_excel(revisedDDpath, sheet = "AAAD_SOCIO_DEMO")
```

<br>

### Handling Logical Variables

```{r AAAD_SOCIO_DEMO-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 121

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## 55 vars

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)]
## [1] "REVIEW_DATE"

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 65 vars

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r AAAD_SOCIO_DEMO-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, can ignore, since it has been converted in last step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r AAAD_SOCIO_DEMO-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 89 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```


```{r AAAD_SOCIO_DEMO-8}
unique(df[["SDF8A"]]) ## DD: 8. Are you working now? Circle all that apply
unique(df[["SDF8B"]]) ## DD: If participant says NO, ask Why not? If any of the following SKIP TO #20

## NOTE: these two variables are good, as they being marked "Multiple" in the [Single, Multiple or Calculated Values] column of DD
```

<br>

### Handling Numeric Variables
```{r AAAD_SOCIO_DEMO-9}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 69 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r AAAD_SOCIO_DEMO-10}
AAAD_SOCIO_DEMO <- df
```


<br>
<br>

## AAAD_TRAILS
Trails

```{r AAAD_TRAILS-1}
df <- AAAD_TRAILS

info(AAAD_TRAILS,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r AAAD_TRAILS-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r AAAD_TRAILS-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r AAAD_TRAILS-4}
dfDD <- read_excel(revisedDDpath, sheet = "AAAD_TRAILS")
```

<br>

### Handling Logical Variables

```{r AAAD_TRAILS-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 3

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)]
## [1] "REVIEW_DATE"

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 2 vars

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r AAAD_TRAILS-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, can ignore, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r AAAD_TRAILS-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 8 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
```

<br>

### Handling Numeric Variables
```{r AAAD_TRAILS-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 23 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP and IND
## need to contact Mike about other variables: TIME_A, TIME_B, COR_B

```

<br>

### Save Cleaned Data

```{r AAAD_TRAILS-9}
AAAD_TRAILS <- df
```


<br>
<br>

## ALZ_B9_JUDGE_RC
B9 Clinician Judgment Symptoms
```{r ALZ_B9_JUDGE_RC-1}
df <- ALZ_B9_JUDGE_RC

info(ALZ_B9_JUDGE_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_B9_JUDGE_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_B9_JUDGE_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r ALZ_B9_JUDGE_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_B9_JUDGE_RC")
```

<br>

### Handling Logical Variables

```{r ALZ_B9_JUDGE_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## MS_ALS_BEGIN_AGE

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"       "REVIEWER"     "MODE_ONSET6A"

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_B9_JUDGE_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_B9_JUDGE_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 17 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)

mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```

<br>

### Handling Numeric Variables
```{r ALZ_B9_JUDGE_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 62 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_B9_JUDGE_RC-9}
ALZ_B9_JUDGE_RC<- df
```


<br>
<br>

## ALZ_CLINICALSUM
ALZHEIMER DISEASE CLINICAL SUMMARY

```{r ALZ_CLINICALSUM-1}
df <- ALZ_CLINICALSUM

info(ALZ_CLINICALSUM,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_CLINICALSUM-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_CLINICALSUM-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r ALZ_CLINICALSUM-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_CLINICALSUM")
```

<br>

### Handling Logical Variables

```{r ALZ_CLINICALSUM-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## LAST_CONTACT_AGE

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## LAST_CONTACT_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## REFCTR

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_CLINICALSUM-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "DATE_OF_BIRTH" "VERIFY_DATE"   "FORM_DATE" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "LAST_CONTACT_DATE" can ignore LAST_CONTACT_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_CLINICALSUM-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 20 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## [1] "IMPRESSION"       "AD_CATEGORY"      "AD_HX_CATEGORY"   "UNCLEAR_CATEGORY"
## after checking the unique values of variables in the mismatchChrs_1, I believe that they all should be characters
## so I updated the DD for those variables (I changed their data type in DD and switch the values from "Valid Responses" and " Valid Responses Codes" columns)

mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## the descrption for variable FILLED_OUT_BY mentioned this is Dropdown style for people to select, so I belive that multiple values are fine
```

<br>

### Handling Numeric Variables
```{r ALZ_CLINICALSUM-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 15 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_CLINICALSUM-9}
ALZ_CLINICALSUM<- df
```


<br>
<br>

## ALZ_CSDD
Cornell Scale for Depression in Dementia

```{r ALZ_CSDD-1}
df <- ALZ_CSDD

info(ALZ_CSDD,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_CSDD-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_CSDD-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r ALZ_CSDD-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_CSDD")
```

<br>

### Handling Logical Variables

```{r ALZ_CSDD-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 1

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_CSDD-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_CSDD-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 8 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
```

<br>

### Handling Numeric Variables
```{r ALZ_CSDD-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 32 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_CSDD-9}
ALZ_CSDD <- df
```


<br>
<br>

## ALZ_EXAM
ALZHEIMER DISEASE CLINICAL EXAM

```{r ALZ_EXAM-1}
df <- ALZ_EXAM

info(ALZ_EXAM,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_EXAM-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_EXAM-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_EXAM-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_EXAM")
```

<br>

### Handling Logical Variables

```{r ALZ_EXAM-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_EXAM-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "FORM_DATE"       "DATE_OF_BIRTH"   "NEURO_EXAM_DATE" "CLIN_EXAM_DATE" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_EXAM-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 66 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore NEURO_METHOD and FILLED_OUT_BY
```

<br>

### Handling Numeric Variables
```{r ALZ_EXAM-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 10 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_EXAM-9}
ALZ_EXAM <- df
```


<br>
<br>

## ALZ_GAI_SP
Geriatric Depression Scale (SPANISH version)
Inventorio de la Ansiedad Geriátrica

```{r ALZ_GAI_SP-1}
df <- ALZ_GAI_SP

info(ALZ_GAI_SP,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_GAI_SP-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_GAI_SP-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_GAI_SP-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_GAI_SP")
```

<br>

### Handling Logical Variables

```{r ALZ_GAI_SP-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR","REVIEWER")
convert2date <- c("REVIEW_DATE")

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r ALZ_GAI_SP-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## "REVIEW_DATE, ignore it, since it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_GAI_SP-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)]
## [1] "LSTUDY"   "DB_OWNER" "STUDY"    "SUBSTUDY" "CENTER"   "REFCTR"   "EXAMINER" "REVIEWER"

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
## ignore EXAMINER, as I assume we can have multiple examiners

```

<br>

### Handling Numeric Variables
```{r ALZ_GAI_SP-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 31 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

```

<br>

### Save Cleaned Data

```{r ALZ_GAI_SP-9}
ALZ_GAI_SP <- df
```


<br>
<br>

## ALZ_LOAD_COG
LOAD Cognitive Measures

```{r ALZ_LOAD_COG-1}
df <- ALZ_LOAD_COG

info(ALZ_LOAD_COG,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_LOAD_COG-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_LOAD_COG-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_LOAD_COG-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_LOAD_COG")
```

<br>

### Handling Logical Variables

```{r ALZ_LOAD_COG-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <-c("REFCTR")
convert2num <-c("FRUITS")

## for others, they are missing info in DD, I will leave them for now

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2num] <- lapply(df[convert2chr], as.numeric)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_LOAD_COG-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Character Variables
```{r ALZ_LOAD_COG-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 9 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore INTERVIEWER
```

<br>

### Handling Numeric Variables
```{r ALZ_LOAD_COG-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 26 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_LOAD_COG-9}
ALZ_LOAD_COG <- df
```


<br>
<br>

## ALZ_NCRAD
ALZHEIMER NCRAD SUPPLEMENTAL FORM

```{r ALZ_NCRAD-1}
df <- ALZ_NCRAD

info(ALZ_NCRAD,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_NCRAD-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_NCRAD-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_NCRAD-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_NCRAD")
```

<br>

### Handling Logical Variables

```{r ALZ_NCRAD-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`,ignore.case = T)] ## 13 vars
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)] ## 5 vars

## convert
df[convert2num] <- lapply(df[convert2chr], as.numeric)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_NCRAD-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "FORM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_NCRAD-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 14 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore FILLED_OUT_BY
```

<br>

### Handling Numeric Variables
```{r ALZ_NCRAD-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 37 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_NCRAD-9}
ALZ_NCRAD <- df
```


<br>
<br>

## ALZ_NEURO_CDR
ALZHEIMER DISEASE CLINICAL DEMENTIA RATING (CDR)

```{r ALZ_NEURO_CDR-1}
df <- ALZ_NEURO_CDR

info(ALZ_NEURO_CDR,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_NEURO_CDR-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_NEURO_CDR-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_NEURO_CDR-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_NEURO_CDR")
```

<br>

### Handling Logical Variables

```{r ALZ_NEURO_CDR-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```


<br>

### Handling Date Variables

```{r ALZ_NEURO_CDR-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_NEURO_CDR-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 10 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore FILLED_OUT_BY
```


<br>

### Handling Numeric Variables
```{r ALZ_NEURO_CDR-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 18 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_NEURO_CDR-9}
ALZ_NEURO_CDR <- df
```

<br>
<br>

## ALZ_NPIQ_CBRS
CERAD Behavior Rating Scale for Dementia

```{r ALZ_NPIQ_CBRS-1}
df <- ALZ_NPIQ_CBRS

info(ALZ_NPIQ_CBRS,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_NPIQ_CBRS-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_NPIQ_CBRS-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_NPIQ_CBRS-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_NPIQ_CBRS")
```

<br>

### Handling Logical Variables

```{r ALZ_NPIQ_CBRS-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_NPIQ_CBRS-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_NPIQ_CBRS-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 11 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore NPIQINF, since it can be multiple values as specified in the DD
```

<br>

### Handling Numeric Variables
```{r ALZ_NPIQ_CBRS-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 103 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_NPIQ_CBRS-9}
ALZ_NPIQ_CBRS <- df
```


<br>
<br>

## ALZ_RPFQ
ALZHEIMER RISK & PROTECTIVE FACTOR QUESTIONNAIRE

```{r ALZ_RPFQ-1}
df <- ALZ_RPFQ

info(ALZ_RPFQ,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_RPFQ-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_RPFQ-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_RPFQ-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_RPFQ")
```

<br>

### Handling Logical Variables

```{r ALZ_RPFQ-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_RPFQ-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_RPFQ-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 17 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r ALZ_RPFQ-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 47 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_RPFQ-9}
ALZ_RPFQ <- df
```


<br>
<br>

## ALZ_SCREENING
ALZHEIMER DISEASE SCREENING STUDIES

```{r ALZ_SCREENING-1}
df <- ALZ_SCREENING

info(ALZ_SCREENING,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_SCREENING-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_SCREENING-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_SCREENING-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_SCREENING")
```

<br>

### Handling Logical Variables

```{r ALZ_SCREENING-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("DATE", dfDD$`Data Type`)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_SCREENING-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "FORM_DATE"      "DATE_OF_BIRTH"  "LUMBAR_DATE"    "BRAIN_MRI_DATE" "BRAIN_CT_DATE"  "EEG_DATE"       "PET_SP_DATE"  

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## "BRAIN_BIO_DATE", ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_SCREENING-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 31 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore FILLED_OUT_BY
```


<br>

### Handling Numeric Variables
```{r ALZ_SCREENING-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 10 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_SCREENING-9}
ALZ_SCREENING <- df
```


<br>
<br>

## ALZ_SCREENING_RC
ALZHEIMER DISEASE SCREENING STUDIES

```{r ALZ_SCREENING_RC-1}
df <- ALZ_SCREENING_RC

info(ALZ_SCREENING_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_SCREENING_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_SCREENING_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r ALZ_SCREENING_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_SCREENING_RC")
```

<br>

### Handling Logical Variables

```{r ALZ_SCREENING_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,,ignore.case = T)] ## 6 vars
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,ignore.case = T)] ## 8 vars
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`,ignore.case = T)] ## 6 vars

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2num] <- lapply(df[convert2chr], as.numeric)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_SCREENING_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "LUMB_DT"       "BRNMRI_DT"     "BRNCT_DT"      "EEG_DT"        "PETSP_DT" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols)
# [1] "REVIEW_DATE"      "BRNBIO_DT"        "DATE_MMSE1"       "DATE_MOCA1"       "DATE_BROOKE1"     "DATE_CHIF1"      
# [7] "DATE_WORDLIST1"   "DATE_OTHER_TEST1"
## these variables have been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_SCREENING_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 29 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r ALZ_SCREENING_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 17 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_SCREENING_RC-9}
ALZ_SCREENING_RC <- df
```

<br>
<br>

## ALZ_STICK_D_RC
Stick Design Test Record Delayed

```{r ALZ_STICK_D_RC-1}
df <- ALZ_STICK_D_RC

info(ALZ_STICK_D_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r ALZ_STICK_D_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r ALZ_STICK_D_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r ALZ_STICK_D_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "ALZ_STICK_D_RC")
```

<br>

### Handling Logical Variables

```{r ALZ_STICK_D_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] ## STATUS_DRSD

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date))

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r ALZ_STICK_D_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r ALZ_STICK_D_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 14 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r ALZ_STICK_D_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 29 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r ALZ_STICK_D_RC-9}
ALZ_STICK_D_RC <- df
```

<br>
<br>

## B4_CDR_RC
CLINICAL DEMENTIA RATING (CDR)

```{r B4_CDR_RC-1}
df <- B4_CDR_RC

info(B4_CDR_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r B4_CDR_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r B4_CDR_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r B4_CDR_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "B4_CDR_RC")
```

<br>

### Handling Logical Variables

```{r B4_CDR_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r B4_CDR_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r B4_CDR_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 16 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r B4_CDR_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 19 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r B4_CDR_RC-9}
B4_CDR_RC <- df
```


<br>
<br>

## B5_NPIQ_RC
Behavioral assessment Neuropsychiatric Inventory Questionnaire (NPI-Q)

```{r B5_NPIQ_RC-1}
df <- B5_NPIQ_RC

info(B5_NPIQ_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r B5_NPIQ_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r B5_NPIQ_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r B5_NPIQ_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "B5_NPIQ_RC")
```

<br>

### Handling Logical Variables

```{r B5_NPIQ_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r B5_NPIQ_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r B5_NPIQ_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 10 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r B5_NPIQ_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 25 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r B5_NPIQ_RC-9}
B5_NPIQ_RC <- df
```


<br>
<br>

## B6_GDS_RC
GERIATRIC DEPRESSION SCALE (GDS)

```{r B6_GDS_RC-1}
df <- B6_GDS_RC

info(B6_GDS_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r B6_GDS_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r B6_GDS_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r B6_GDS_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "B6_GDS_RC")
```

<br>

### Handling Logical Variables

```{r B6_GDS_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("DATE", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r B6_GDS_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols)
# [1] "REVIEW_DATE", ignore it, this variables have been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r B6_GDS_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 9 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r B6_GDS_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 27 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r B6_GDS_RC-9}
B6_GDS_RC <- df
```

<br>
<br>

## B7_FAS_RC
 Functional Assessment Scale
 
```{r B7_FAS_RC-1}
df <- B7_FAS_RC

info(B7_FAS_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r B7_FAS_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r B7_FAS_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r B7_FAS_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "B7_FAS_RC")
```

<br>

### Handling Logical Variables

```{r B7_FAS_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r B7_FAS_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r B7_FAS_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 9 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r B7_FAS_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 21 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r B7_FAS_RC-9}
B7_FAS_RC<- df
```


<br>
<br>

## BCF_RECOG_RC
Benson Complex Figure Copy Recognition

```{r BCF_RECOG_RC-1}
df <- BCF_RECOG_RC

info(BCF_RECOG_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r BCF_RECOG_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r BCF_RECOG_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r BCF_RECOG_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "BCF_RECOG_RC")
```

<br>

### Handling Logical Variables

```{r BCF_RECOG_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r BCF_RECOG_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r BCF_RECOG_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 9 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r BCF_RECOG_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 12 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r BCF_RECOG_RC-9}
BCF_RECOG_RC <- df
```

<br>
<br>

## BCFCD_RC
Benson Complex Figure Copy (Delayed)

```{r BCFCD_RC-1}
df <- BCFCD_RC

info(BCFCD_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r BCFCD_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r BCFCD_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r BCFCD_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "BCFCD_RC")
```

<br>

### Handling Logical Variables

```{r BCFCD_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## "REFCTR" "REVIEWER" "TOTAL_SCORE_BENSON_DEL_STATUS"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r BCFCD_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r BCFCD_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 13 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r BCFCD_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 22 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r BCFCD_RC-9}
BCFCD_RC <- df
```

<br>
<br>

## BCFCI_RC
Benson Complex Figure Copy (Immediate)

```{r BCFCI_RC-1}
df <- BCFCI_RC

info(BCFCI_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r BCFCI_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r BCFCI_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r BCFCI_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "BCFCI_RC")
```

<br>

### Handling Logical Variables

```{r BCFCI_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"  "REVIEWER"  "BCF_COPY_SCORE_STATUS"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r BCFCI_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, as it has been converted in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r BCFCI_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 13 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r BCFCI_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 22 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r BCFCI_RC-9}
BCFCI_RC <- df
```


<br>
<br>

## BILINGUAL_SCALE_RC
Bilingual Scale

```{r BILINGUAL_SCALE_RC-1}
df <- BILINGUAL_SCALE_RC

info(BILINGUAL_SCALE_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r BILINGUAL_SCALE_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r BILINGUAL_SCALE_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r BILINGUAL_SCALE_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "BILINGUAL_SCALE_RC")
```

<br>

### Handling Logical Variables

```{r BILINGUAL_SCALE_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 23 vars

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date))

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r BILINGUAL_SCALE_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r BILINGUAL_SCALE_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 33 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r BILINGUAL_SCALE_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 15 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r BILINGUAL_SCALE_RC-9}
BILINGUAL_SCALE_RC <- df
```

<br>
<br>

## CAT_FLUENCY_RC
Category Fluency

```{r CAT_FLUENCY_RC-1}
df <- CAT_FLUENCY_RC

info(CAT_FLUENCY_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CAT_FLUENCY_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CAT_FLUENCY_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CAT_FLUENCY_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CAT_FLUENCY_RC")
```

<br>

### Handling Logical Variables

```{r CAT_FLUENCY_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CAT_FLUENCY_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CAT_FLUENCY_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 11 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CAT_FLUENCY_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 15 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CAT_FLUENCY_RC-9}
CAT_FLUENCY_RC <- df
```


<br>
<br>

## CERAD_DEL_RC
CERAD Word Delay Recall

```{r CERAD_DEL_RC-1}
df <- CERAD_DEL_RC

info(CERAD_DEL_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CERAD_DEL_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CERAD_DEL_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CERAD_DEL_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CERAD_DEL_RC")
```

<br>

### Handling Logical Variables

```{r CERAD_DEL_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CERAD_DEL_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CERAD_DEL_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 13 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## [1] SCALES_CERADRECALL
## SCALES_CERADRECALL shows numeric in DD, but read in as character
## the reason it pops up is because they use "na" to represent the NAs
## I will correct it and convert it to numeric

df$SCALES_CERADRECALL[df$SCALES_CERADRECALL == "na"] <- NA
unique(df$SCALES_CERADRECALL)
df$SCALES_CERADRECALL <- as.numeric(df$SCALES_CERADRECALL)

mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CERAD_DEL_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 29 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CERAD_DEL_RC-9}
CERAD_DEL_RC <- df
```


<br>
<br>

## CERAD_IMM_RC
CERAD Word Immediate Recall

```{r CERAD_IMM_RC-1}
df <- CERAD_IMM_RC

info(CERAD_IMM_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CERAD_IMM_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CERAD_IMM_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CERAD_IMM_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CERAD_IMM_RC")
```

<br>

### Handling Logical Variables

```{r CERAD_IMM_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CERAD_IMM_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CERAD_IMM_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 17 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CERAD_IMM_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 68 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CERAD_IMM_RC-9}
CERAD_IMM_RC <- df
```


<br>
<br>

## CERAD_RECOG_RC
CERAD Word Recognition

```{r CERAD_RECOG_RC-1}
df <- CERAD_RECOG_RC

info(CERAD_RECOG_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CERAD_RECOG_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CERAD_RECOG_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CERAD_RECOG_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CERAD_RECOG_RC")
```

<br>

### Handling Logical Variables

```{r CERAD_RECOG_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"  "REVIEWER" "WLRG_YES_STATUS" "WLRG_NO_STATUS" 

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CERAD_RECOG_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CERAD_RECOG_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 11 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CERAD_RECOG_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 34 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CERAD_RECOG_RC-9}
CERAD_RECOG_RC <- df
```


<br>
<br>

## CONSENSUS_DX

```{r CONSENSUS_DX-1}
df <- CONSENSUS_DX

info(CONSENSUS_DX,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CONSENSUS_DX-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CONSENSUS_DX-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CONSENSUS_DX-4}
dfDD <- read_excel(revisedDDpath, sheet = "CONSENSUS_DX")
```

<br>

### Handling Logical Variables

```{r CONSENSUS_DX-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to numeric
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`)] 
## 11 vars

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## OTHER_DATE1

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) 
## "REFCTR"  "CLINICAL_COMMENTS" "OTHER_TXT1"  "OTHER_TXT2"  "OTHER_TXT3" 

## convert
df[convert2num] <- lapply(df[convert2num], as.numeric)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CONSENSUS_DX-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "REVIEW_DATE"   "DATE_OF_BIRTH" "DATE_DX"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "OTHER_DATE1" can ignore OTHER_DATE1, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CONSENSUS_DX-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 17 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## Ignore REVIEWER, for others, waiting for confirmation from Mike, should I add those invalid values to the DD?
```

<br>

### Handling Numeric Variables
```{r CONSENSUS_DX-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 22 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CONSENSUS_DX-9}
CONSENSUS_DX <- df
```

<br>
<br>

## CRAFT_21_DEL_RC

```{r CRAFT_21_DEL_RC-1}
df <- CRAFT_21_DEL_RC

info(CRAFT_21_DEL_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CRAFT_21_DEL_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CRAFT_21_DEL_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CRAFT_21_DEL_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CRAFT_21_DEL_RC")
```

<br>

### Handling Logical Variables

```{r CRAFT_21_DEL_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"         "REVIEWER"       "CRAFTDVR_ENTRY"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CRAFT_21_DEL_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "CRAFTDTI"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CRAFT_21_DEL_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 10 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CRAFT_21_DEL_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 81 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CRAFT_21_DEL_RC-9}
CRAFT_21_DEL_RC <- df
```

<br>
<br>

## CRAFT_21_IMM_RC

```{r CRAFT_21_IMM_RC-1}
df <- CRAFT_21_IMM_RC

info(CRAFT_21_IMM_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r CRAFT_21_IMM_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r CRAFT_21_IMM_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r CRAFT_21_IMM_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "CRAFT_21_IMM_RC")
```

<br>

### Handling Logical Variables

```{r CRAFT_21_IMM_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## "REFCTR"         "REVIEWER"       "CRAFTVRS_ENTRY"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r CRAFT_21_IMM_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "CRAFTVRS_TIME" 

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
## I will leave CRAFTVRS_TIME with format POSIXct since it contains the timestamp
## and I will convert the other two to date format
datecols <- setdiff(datecols, "CRAFTVRS_TIME")
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r CRAFT_21_IMM_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 12 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```

<br>

### Handling Numeric Variables
```{r CRAFT_21_IMM_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 82 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r CRAFT_21_IMM_RC-9}
CRAFT_21_IMM_RC <- df
```


<br>
<br>

## MEDCON_RC

```{r MEDCON_RC-1 }
df <- MEDCON_RC

info(MEDCON_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MEDCON_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MEDCON_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MEDCON_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "MEDCON_RC")
```

<br>

### Handling Logical Variables

```{r MEDCON_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 7 vars

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)]
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,ignore.case = T)]
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`,ignore.case = T)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2num] <- lapply(df[convert2num], as.numeric)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MEDCON_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH" "DATE_OF_ONSET"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MEDCON_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 69 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## 9 vars
## [1] "SEEN2"  "SEEN4"  "SEEN6"  "SEEN8"  "SEEN10" "SEEN12" "SEEN14" "SEEN16" "SEEN18"
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## convert mismatchChrs_1 vars to numeric
df[mismatchChrs_1] <- lapply(df[mismatchChrs_1], as.numeric)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r MEDCON_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 164 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MEDCON_RC-9}
MEDCON_RC <- df
```

<br>
<br>

## MEDICAL_HIST
Medical History

```{r MEDICAL_HIST-1}
df <- MEDICAL_HIST

info(MEDICAL_HIST,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MEDICAL_HIST-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MEDICAL_HIST-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MEDICAL_HIST-4}
dfDD <- read_excel(revisedDDpath, sheet = "MEDICAL_HIST")
```

<br>

### Handling Logical Variables

```{r MEDICAL_HIST-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`)]

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MEDICAL_HIST-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## character(0)

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MEDICAL_HIST-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 40 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore CANCER_TYPE, as it is a multiple values variable
```


<br>

### Handling Numeric Variables
```{r MEDICAL_HIST-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 11 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MEDICAL_HIST-9}
MEDICAL_HIST <- df
```


<br>
<br>

## MINT_RC
Multilingual Naming Test

```{r MINT_RC-1}
df <- MINT_RC

info(MINT_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MINT_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MINT_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MINT_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "MINT_RC")
```

<br>

### Handling Logical Variables

```{r MINT_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)] ## 115 vars 

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)] ## 31 vars
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,,ignore.case = T)] ## 1 var
convert2num <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("NUMBER", dfDD$`Data Type`,,ignore.case = T)] ## 83 vars

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2num] <- lapply(df[convert2date], as.numeric)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MINT_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MINT_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 42 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r MINT_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 176 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MINT_RC-9}
MINT_RC <- df
```


<br>
<br>

## MINT_SP_RC

```{r MINT_SP_RC-1}
df <- MINT_SP_RC

info(MINT_SP_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MINT_SP_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MINT_SP_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MINT_SP_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "MINT_SP_RC")
```

<br>

### Handling Logical Variables

```{r MINT_SP_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## converted to character
convert2chr <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("CHAR", dfDD$`Data Type`,ignore.case = T)] ## 2 vars
convert2date <- dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date", dfDD$`Data Type`,,ignore.case = T)] ## 1 var

## convert
df[convert2chr] <- lapply(df[convert2chr], as.character)
df[convert2date] <- lapply(df[convert2date], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MINT_SP_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## REVIEW_DATE, ignore it, it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MINT_SP_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 42 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

## ignore EXAMINER
```


<br>

### Handling Numeric Variables
```{r MINT_SP_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 176 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MINT_SP_RC-9}
MINT_SP_RC <- df
```

<br>
<br>

## MOCA_RC

```{r MOCA_RC-1}
df <- MOCA_RC

info(MOCA_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r MOCA_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r MOCA_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>

### Pull the regenerated DD

```{r MOCA_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "MOCA_RC")
```

<br>

### Handling Logical Variables

```{r MOCA_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## 17 vars

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r MOCA_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"      "DATE_OF_BIRTH"  "MOCAORDT_ENTRY"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date","Date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r MOCA_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 46 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0) 
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))
```

<br>

### Handling Numeric Variables
```{r MOCA_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 90 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r MOCA_RC-9}
MOCA_RC <- df
```

<br>
<br>

## NUMBER_SPAN_RC

```{r NUMBER_SPAN_RC-1}
df <- NUMBER_SPAN_RC

info(NUMBER_SPAN_RC,"SYSIND")

## extract all the unique data types
unique(sapply(df, class))
```

```{r NUMBER_SPAN_RC-2,eval=FALSE}
str(df, max.level = 99, list.len = 99999)
```
<details>
<summary>Click for details</summary>
```{r NUMBER_SPAN_RC-3, echo=FALSE, eval=TRUE}
str(df, max.level = 99, list.len = 99999)
```
</details> 

<br>


### Pull the regenerated DD

```{r NUMBER_SPAN_RC-4}
dfDD <- read_excel(revisedDDpath, sheet = "NUMBER_SPAN_RC")
```

<br>

### Handling Logical Variables

```{r NUMBER_SPAN_RC-5}
## extract all logical variables
logicols <- colnames(df)[sapply(df, is.logical)]

## view those variables in the regeneraed DD
dfDD[dfDD$VarNames %in% logicols,c("VarNames","Data Type")]

## select the vars to be converted to date
convert2date <-  dfDD$VarNames[dfDD$VarNames %in% logicols & grepl("date",dfDD$`Data Type`,ignore.case = T)] ## REVIEW_DATE

## the rest should be converted to character
convert2chr <- setdiff(logicols,c(convert2num,convert2date)) ## [1] "REFCTR"   "REVIEWER"

## convert
df[convert2date] <- lapply(df[convert2date], as.Date)
df[convert2chr] <- lapply(df[convert2chr], as.character)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Date Variables

```{r NUMBER_SPAN_RC-6}
## extract date variables from sub-dataset
datecols <- colnames(df)[sapply(df, function(x) inherits(x, c("POSIXct", "POSIXt")))]
## [1] "EXAM_DATE"     "DATE_OF_BIRTH"

## extract date variables from regenerated DD
datecolsFromDD <- dfDD$VarNames[dfDD$`Data Type` %in% c("DATE","date")]

## compare the two to see if we missing any date variables
setdiff(datecols,datecolsFromDD) ## character(0)
setdiff(datecolsFromDD,datecols) ## [1] "REVIEW_DATE" can ignore REVIEW_DATE, as it has been corrected in previous step

head(df[,datecols])

## convert format
df[datecols] <- lapply(df[datecols], as.Date)

## recheck the unique data types
unique(sapply(df, class))
```

<br>

### Handling Character Variables
```{r NUMBER_SPAN_RC-7}
## extract characteristic variables from sub-dataset
chrcols <- colnames(df)[sapply(df, is.character)] ## 39 vars

## check data type inconsistency:
## mismatchChrs_1: present as chr in data but others in the DD
## mismatchChrs_2: present as chr in DD but others in the data
chrColsfromDD <- dfDD[grepl("^(varchar|char)", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Data Type")]

mismatchChrs_1 <- setdiff(chrcols,chrColsfromDD$VarNames) ## character(0)
mismatchChrs_2 <- setdiff(chrColsfromDD$VarNames,chrcols) ## character(0)

## extract characteristic variables with value specification
tmp <- dfDD[grepl("CHAR|VARCHAR", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

## check if the unique values for the chr columns in the dataset matching with the DD
DT::datatable(check_valid_responses(tmp,df))

```

<br>

### Handling Numeric Variables
```{r NUMBER_SPAN_RC-8}
## extract numeric variables from sub-dataset
numcols <- colnames(df)[sapply(df, is.numeric)] ## 43 vars

## extract numeric variables from DD

## check data type inconsistency:
## mismatchNums_1: present as numeric in data but others in the DD
## mismatchNums_2: present as numeric in DD but others in the data
numColsfromDD <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE),c("VarNames","Valid Responses")]

mismatchNums_1 <- setdiff(numcols,numColsfromDD$VarNames) ## character(0)
mismatchNums_2 <- setdiff(numColsfromDD$VarNames,numcols) ## character(0)

unique(numColsfromDD$`Valid Responses`)

tmp <- dfDD[grepl("number", dfDD$`Data Type`, ignore.case = TRUE) & !is.na(dfDD$`Valid Responses`),c("VarNames","Valid Responses")]

DT::datatable(check_valid_numeric_responses(tmp,df))

## ignore GP
```

<br>

### Save Cleaned Data

```{r NUMBER_SPAN_RC-9}
NUMBER_SPAN_RC <- df
```

<br>
<br>

# Common Columns Handling

Among the common columns shared across all datasets:

<mark>
[1] "SYSXM"       "SYSIND"      "SYSGP"       "SYSGPSTUDY"   
[5] "SYSINDGP"    "CGI_ORDER"   "GPS_ORDER"   "STDCGI_ORDER" 
[9] "LSTUDY"      "DB_OWNER"    "STUDY"       "SUBSTUDY"     
[13] "CENTER"      "GP"          "IND"         "REFCTR"       
[17] "DATE_OF_BIRTH"
</mark>

The variable SYSXM is unique within each dataset and not informative, except for the PRADI team. These can likely be dropped.
Except for SYSIND, the other common variables can be removed from the main datasets and stored separately in a dedicated data frame containing only these shared columns. And they will be merged back to the final dataset.

```{r}
## drop SYSXM for all datasets
for (df_name in df_names) {
  df <- get(df_name)   # retrieve the dataset by name
  df <- df[ , !(names(df) %in% c("SYSXM"))] # drop 
  assign(df_name, df)  # save the modified dataset back
}

common_cols2keep <- setdiff(common_cols,c("SYSXM"))
common_cols2drop <- setdiff(common_cols2keep,"SYSIND")

df_common_cols <- list() 

## collect and then remove all other common columns for all datasets
for (df_name in df_names) {
  df <- get(df_name)   # retrieve the dataset by name
  
  df_common_cols[[df_name]] <- df[,common_cols2keep]
  
  df <- df[ , !(names(df) %in% common_cols2drop)] 
  
  assign(df_name, df)  # save the modified dataset back
}

df_common_cols <- do.call(rbind, df_common_cols)
df_common_cols <- df_common_cols %>% distinct()
rownames(df_common_cols) <- NULL
str(df_common_cols)

```


<br>
<br>

# Duplicates Check

## Duplicates Detection

```{r dupCheck-1}
## Before checking duplicates by SYSIND and date variables,
## first remove general duplicates. 
## (Since we dropped SYSXM earlier, some duplicates might have been missed 
## before removing the SYSXM column.)

for (df_name in df_names) {
  df <- get(df_name)
  df <- distinct(df)
  assign(df_name, df)
}

```


```{r dupCheck-2}
# Get names of all data frames in the environment
longDfwithDuplicates <- c()
otherwithDuplicates <- c()
index = 0

## following function will do:
## 1. filter out the okay cross-sectional datasets
## 2. for the rest: return the longitudinal/cross-sectional dataset names if duplicates got detected
for (df_name in df_names) {
  df <- get(df_name)
  
  ## filter out the okay cross-sectional datasets
  if (length(unique(df[["SYSIND"]])) == nrow(df)) {
    index = index + 1
    cat(index,
        "No duplicates found in cross-sectional dataset: ",
        df_name,
        "\n")
  } else{
    ## Check if columns ID and Visit exist (longitduinal data or not)
    if (all(c("SYSIND", "EXAM_DATE") %in% colnames(df))) {
      # Find duplicates using dplyr
      dup_rows <- df %>%
        dplyr::group_by(SYSIND, EXAM_DATE) %>%
        dplyr::filter(n() > 1) %>%
        dplyr::ungroup()
      
      # If any duplicates found, assign to new data frame with _Duplicates
      if (nrow(dup_rows) > 0) {
        longDfwithDuplicates <- c(longDfwithDuplicates, df_name)
      } else {
        index = index + 1
        cat(index,
            "No duplicates found in longitudinal dataset: ",
            df_name,
            "\n")
      }
    } else {
      otherwithDuplicates <- c(otherwithDuplicates, df_name)
    }
  }
}
```

<br>


```{r dupCheck-3}
## longidtudinal datatset with duplicate
longDfwithDuplicates
```

```{r dupCheck-4}
## otherwithDuplicates
## the following variables do not have EXAM_DATE but have other time variables
## so I will check duplicates one by one for them based on their unique time variables
otherwithDuplicates
```

```{r dupCheck-5}
## check duplicates for ALZ_CLINICALSUM
ALZ_CLINICALSUM %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## check duplicates for ALZ_EXAM
ALZ_EXAM %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## check duplicates for ALZ_LOAD_COG
ALZ_LOAD_COG %>%
  dplyr::group_by(SYSIND, INTERVIEW_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## check duplicates for ALZ_NCRAD
ALZ_NCRAD %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## ALZ_SCREENING
ALZ_SCREENING %>%
  dplyr::group_by(SYSIND, FORM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 0 row

## CONSENSUS_DX
CONSENSUS_DX %>%
  dplyr::group_by(SYSIND, DATE_DX) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup() %>%
  nrow() %>% print() ## 211 rows

```


<br>
<br>

## Duplicates Handling Per Dataset

### ALZ_NPIQ_CBRS

```{r dupHandle-1}
cat("Before duplicates handling - SYSIND*EXAM_DATE is: ",dupFixCheck(ALZ_NPIQ_CBRS,"SYSIND","EXAM_DATE"),"\n")
```

```{r dupHandle-2}
info(ALZ_NPIQ_CBRS,"SYSIND")
```

```{r dupHandle-3}
## view the duplicates
ALZ_NPIQ_CBRS %>%
  dplyr::group_by(SYSIND, EXAM_DATE) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup()
```

```{r dupHandle-4}
## keep the obs with less missingness
ALZ_NPIQ_CBRS <- ALZ_NPIQ_CBRS %>%
  group_by(SYSIND, EXAM_DATE) %>%
  # calculate number of missing values per row
  mutate(n_missing = rowSums(is.na(across(everything())))) %>%
  # keep the row(s) with the minimum number of missing values
  filter(n_missing == min(n_missing)) %>%
  ungroup() %>%
  select(-n_missing)   

```

```{r dupHandle-5}
info(ALZ_NPIQ_CBRS,"SYSIND")
```

```{r dupHandle-6}
cat("After duplicates handling - SYSIND*EXAM_DATE is: ",dupFixCheck(ALZ_NPIQ_CBRS,"SYSIND","EXAM_DATE"),"\n")
```

<br>
<br>

### CONSENSUS_DX

```{r dupHandle-13}
cat("Before duplicates handling - SYSIND*DATE_DX is: ",dupFixCheck(CONSENSUS_DX,"SYSIND","DATE_DX"),"\n")
```

```{r dupHandle-14}
info(CONSENSUS_DX,"SYSIND")
```

```{r dupHandle-15}
## view the duplicates
CONSENSUS_DX %>%
  dplyr::group_by(SYSIND, DATE_DX) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup()

table(CONSENSUS_DX$RANK)
``` 

```{r dupHandle-16}
## Not very much participants got second or thid diagnosis.
## I decided to split the dataset CONSENSUS_DX into three: CONSENSUS_DX_1, CONSENSUS_DX_2, CONSENSUS_DX_3
## And then handle the duplicates one by one
table(CONSENSUS_DX$RANK)

CONSENSUS_DX_1 <- CONSENSUS_DX[CONSENSUS_DX$RANK == 1,]

CONSENSUS_DX_1 %>%
  dplyr::group_by(SYSIND, DATE_DX) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup()

## there are two obs for individual 11040003, I will keep the second obs as it got more information
CONSENSUS_DX_1 <- CONSENSUS_DX_1 %>%
   filter(!(SYSIND == 11040003 & REVIEW_DATE == as.Date("2022-01-20")))

```

```{r dupHandle-17}
CONSENSUS_DX_2 <- CONSENSUS_DX[CONSENSUS_DX$RANK == 2,]

CONSENSUS_DX_2 %>%
  dplyr::group_by(SYSIND, DATE_DX) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup()
## no duplicates
```

```{r dupHandle-18}
CONSENSUS_DX_3 <- CONSENSUS_DX[CONSENSUS_DX$RANK == 3,]

CONSENSUS_DX_3 %>%
  dplyr::group_by(SYSIND, DATE_DX) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::ungroup()

## no duplicates
```

```{r dupHandle-19}
## update the df_names
df_names <- setdiff(df_names,"CONSENSUS_DX")
df_names <- c(df_names,"CONSENSUS_DX_1","CONSENSUS_DX_2","CONSENSUS_DX_3")
print(df_names)
```

<br>
<br>


# Individuals Count

## Total Number of Individuals
```{r pp-count-1}
## get total number of unique inviduals
all_ids <- unlist(
  lapply(df_names, function(d) get(d)$SYSIND)
)

# Count unique SYSINDs
all_ids <- unique(all_ids)
length(all_ids) ## 1994 individuals
```

<br>

## Individual by Study Presence Check
```{r}
# Initialize a matrix with colored HTML symbols
presence_mat <- sapply(df_names, function(dfn) {
  df <- get(dfn)  # get the dataset by name
  present <- all_ids %in% df$SYSIND
  ifelse(
    present,
    '<span style="color:darkgreen; font-weight:bold;">✔</span>',
    '<span style="color:darkred; font-weight:bold;">✘</span>'
  )
})

# Convert to data frame
presence_df <- data.frame(ID = all_ids, presence_mat, check.names = FALSE)

# columns to center (all except ID)
center_targets <- if (ncol(presence_df) > 1) 1:(ncol(presence_df) - 1) else integer(0)

DT::datatable(
  presence_df,
  escape = FALSE,
  rownames = FALSE,
  options = list(
    pageLength = 50,
    scrollX = TRUE,
    columnDefs = list(
      list(className = "dt-center", targets = center_targets) # 0-based indexing
    )
  )
)

```


<br>

## Individuals Missingness Per Study

```{r pp-count-2}
summary_df <- do.call(rbind, lapply(df_names, function(d) {
  df <- get(d)
  df_individuals <- unique(df$SYSIND)
  
  data.frame(
    dataset   = d,
    n_individuals = length(df_individuals),
    n_obs         = nrow(df),
    n_individials_missing   = length(setdiff(all_ids, df_individuals)),
    stringsAsFactors = FALSE
  )
}))

DT::datatable(summary_df)
## n_individuals: number of individuals present in the dataset
## n_obs: total number of observations in the dataset
## n_individials_missing: number of individuals (out of 1994) not present in the dataset

```

<br>
<br>

# Data Process before Merge

## Grouping Datasets

```{r}
cross_dfs<- c()
long_dfs_wEXAM_DATE <- c()
long_dfs_woEXAM_DATE <- c()

for (df_name in df_names) {
  df_obj <- get(df_name)  # get the dataframe
  if (nrow(df_obj) == length(unique(df_obj[["SYSIND"]]))) {
    cross_dfs <- c(cross_dfs, df_name)
  } else if ("EXAM_DATE" %in% names(df_obj)) {
    long_dfs_wEXAM_DATE <- c(long_dfs_wEXAM_DATE, df_name)
  } else{
    long_dfs_woEXAM_DATE <- c(long_dfs_woEXAM_DATE,df_name)
  }
}

cross_dfs
long_dfs_wEXAM_DATE
long_dfs_woEXAM_DATE
```


```{r}
dfwEXAM_DATE <- c()
dfwoEXAM_DATE <- c()

for (df_name in df_names) {
  df_obj <- get(df_name)  # get the dataframe
  
  if ("EXAM_DATE" %in% names(df_obj)) {
    dfwEXAM_DATE <- c(dfwEXAM_DATE, df_name)
  } else{
    dfwoEXAM_DATE <- c(dfwoEXAM_DATE,df_name)
  }
  
}

print(dfwEXAM_DATE)

print(dfwoEXAM_DATE)
```


<br>
<br>

## AGE_AT_EXAM Variable Explore

```{r}
## detect which dataset has AGE_AT_EXAM variable
index = 1

for (df_name in df_names) {
  df_obj <- get(df_name, inherits = TRUE)
  nms <- names(df_obj)

  has_age  <- "AGE_AT_EXAM" %in% nms
  has_date <- "EXAM_DATE"   %in% nms

  if (has_age && has_date) {
    cat(index, ":", df_name, ": both EXAM_DATE and AGE_AT_EXAM present\n")
  } else if (has_age && !has_date) {
    cat(index, ":", df_name, ": only AGE_AT_EXAM present\n")
  } else if (has_date && !has_age) {
    cat(index, ":", df_name, ": only EXAM_DATE present\n")
  } else {
    cat(index, ":", df_name, ": ============ none of them present ============\n")
  }

  index <- index + 1
}

```

<mark>**Findings:** AGE_AT_EXAM and EXAM_DATE variables are paired. If one presents, the other also presents.</mark>


```{r}
## group by SYSIND and AGE_AT_EXAM then check duplicates
index = 1
for (df_name in df_names) {
  df_obj <- get(df_name)  # get the dataframe
  if ("AGE_AT_EXAM" %in% names(df_obj)) {
    cat(index, " :", df_name, " : AGE_AT_EXAM present", "\n")
    
    dup_rows_AGE_AT_EXAM <- df_obj %>%
      dplyr::group_by(SYSIND, AGE_AT_EXAM) %>%
      dplyr::filter(n() > 1) %>%
      dplyr::ungroup()
    
    dup_rows_EXAM_DATE <- df_obj %>%
      dplyr::group_by(SYSIND, EXAM_DATE) %>%
      dplyr::filter(n() > 1) %>%
      dplyr::ungroup()
    
    if (nrow(dup_rows_AGE_AT_EXAM) > 0) {
      cat(index,
          " :",
          df_name,
          " : !!!duplicates present (checking by AGE_AT_EXAM )!!!",
          "\n")
    } else if (nrow(dup_rows_EXAM_DATE) > 0) {
      cat(index,
          " :",
          df_name,
          " : !!!duplicates present (checking by EXAM_DATE )!!!",
          "\n")
    } else{
      cat(index, " :", df_name, " : no duplicates found:)", "\n")
    }
    
  } else{
    cat(index, " :", df_name, "===============================================","\n")
  }
  index = index + 1
}
```


<mark>**Findings:** when mergeing, AGE_AT_EXAM can not be used as the key column, cause duplicates existed for some people with different AGE_AT_EXAM
after rounding up, those obs have same AGE_AT_EXAM values.</mark>


<br>
<br>

## Generate Visit Index Variable for Individuals

```{r}
##########################################################################################
## for every individual, get all their date data
ppdat <- data.frame(SYSIND = numeric(0), EXAM_DATE = as.Date(character(0)), fromData = character(0))

## for dataset with EXAM_DATE, we just need to extract the relevant information and appending to the ppdat
for (df_name in dfwEXAM_DATE) {
  df_obj <- get(df_name)  # get the dataframe

  tmp <- data.frame(
    SYSIND = df_obj[["SYSIND"]],
    EXAM_DATE = df_obj[["EXAM_DATE"]],
    fromData = df_name
  )
  
  ppdat <- rbind(ppdat,tmp)
}

ppdat <- ppdat[!duplicated(ppdat),]

##----------------------------------------------------------------------------
## for dataset without EXAM_DATE, extract other data variables and appending to the ppdat

## ALZ_CLINICALSUM: has FORM_DATE
## ALZ_EXAM: has FORM_DATE
## ALZ_LOAD_COG: has INTERVIEW_DATE
## ALZ_NCRAD: has FORM_DATE
## ALZ_SCREENING: has FORM_DATE
## CONSENSUS_DX_1: DATE_DX
## CONSENSUS_DX_2: DATE_DX
## CONSENSUS_DX_3: DATE_DX

dfwFORM_DATE <- c("ALZ_CLINICALSUM","ALZ_EXAM","ALZ_NCRAD","ALZ_SCREENING")
for (df_name in dfwFORM_DATE) {
  df_obj <- get(df_name)  # get the dataframe
  
   tmp <- data.frame(
    SYSIND = df_obj[["SYSIND"]],
    EXAM_DATE = df_obj[["FORM_DATE"]],
    fromData = df_name
  )
  ppdat <- rbind(ppdat,tmp)
}

ppdat <- ppdat[!duplicated(ppdat),]

##----------------------------------------------------------------------------
df_obj <- ALZ_LOAD_COG

tmp <- data.frame(SYSIND = df_obj[["SYSIND"]],
                  EXAM_DATE = df_obj[["INTERVIEW_DATE"]],
                  fromData = "ALZ_LOAD_COG")

ppdat <- rbind(ppdat,tmp)
ppdat <- ppdat[!duplicated(ppdat),]

##----------------------------------------------------------------------------
for (df_name in c("CONSENSUS_DX_1","CONSENSUS_DX_2","CONSENSUS_DX_3")) {
  df_obj <- get(df_name)  # get the dataframe

  tmp <- data.frame(
    SYSIND = df_obj[["SYSIND"]],
    EXAM_DATE = df_obj[["DATE_DX"]],
    fromData = df_name
  )
  
  ppdat <- rbind(ppdat,tmp)
}

ppdat <- ppdat[!duplicated(ppdat),]

##----------------------------------------------------------------------------

info(ppdat,"SYSIND") #obs:5204, cols:2, inds:1994
sorted_ppdat <- ppdat %>% arrange(SYSIND, EXAM_DATE)

##########################################################################################
## check the time range between visits and get the distribution plot

# Step 1: Calculate intervals per individual
sorted_ppdat_intervals <- sorted_ppdat %>%
  group_by(SYSIND) %>%
  mutate(interval_days = as.numeric(difftime(EXAM_DATE, lag(EXAM_DATE), units = "days"))) %>%
  mutate(interval_month = interval_days/30.436875) %>%
  ungroup()

# Step 2: Look at the intervals (excluding first visit per subject which is NA)
DT::datatable(sorted_ppdat_intervals)

# Step 3: Plot histogram of all intervals
hist(sorted_ppdat_intervals$interval_month)

summary(sorted_ppdat_intervals$interval_month)
##########################################################################################
## creating the Visit Index variable
## If a subject’s next exam is < 3 months after the last one, it stays in the same visit.
## If it’s ≥ 3 months, it becomes the next visit.
## Starts at 1 for each subject.

sorted_ppdat2 <- sorted_ppdat %>%
  group_by(SYSIND) %>%
  group_modify(~{
    df <- .x
    n  <- nrow(df)
    idx <- integer(n)
    if (n == 0) return(df)
    v <- 1L
    start <- df$EXAM_DATE[1]
    idx[1] <- v
    if (n > 1) {
      for (i in 2:n) {
        # start a new visit if current date is >= 3 months after the anchor
        if (df$EXAM_DATE[i] >= (start %m+% months(3))) {
          v <- v + 1L
          start <- df$EXAM_DATE[i]
        }
        idx[i] <- v
      }
    }
    df$Visit_Index <- idx
    df
  }) %>%
  ungroup()


## Visit summary
visit_summary <- sorted_ppdat2 %>%
  group_by(SYSIND) %>%
  summarise(
    total_visits = n_distinct(Visit_Index),
    total_obs    = n(),                 # how many raw rows for this person
    first_date   = min(EXAM_DATE, na.rm = TRUE),
    last_date    = max(EXAM_DATE, na.rm = TRUE),
    span_days    = as.integer(last_date - first_date)
  ) %>%
  arrange(desc(total_visits))

DT::datatable(visit_summary)

```



<br>
<br>

## Add Visit Index Back to Dataset

```{r}
## add Visit index back to each dataset
sorted_ppdat3 <- sorted_ppdat2 %>%
  select(SYSIND,EXAM_DATE,Visit_Index) %>%
  distinct()

## for dataset with EXAM_DATE variable:
index = 1
for (df_name in dfwEXAM_DATE) {
  
  cat("======================================================================","\n")
  df_obj <- get(df_name)  # get the dataframe
  
  cat(index,": Currently processing dataset: ",df_name,"\n")
  cat("Dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  cat("\n")
  num_miss <- nrow(df_obj[is.na(df_obj[["EXAM_DATE"]]),])
  cat("NUmber of observations missing in EXAM_DATE: ",num_miss, "\n")
  
  df_obj <- merge(df_obj,sorted_ppdat3,by=c("SYSIND","EXAM_DATE"))
  
  cat("\n")
  cat("After adding visit index, dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  ## change dataset name
  newdfname <- paste0("wVisitIndex_",df_name)
  assign(newdfname, df_obj)
  
  index = index + 1
}

```


```{r}
## Now add visit index to dataset with FORM_DATE
sorted_ppdat3 <- sorted_ppdat2 %>%
  select(SYSIND,EXAM_DATE,Visit_Index) %>%
  distinct()

names(sorted_ppdat3)[names(sorted_ppdat3)=="EXAM_DATE"] <- "FORM_DATE"

for (df_name in dfwFORM_DATE) {
  cat("======================================================================","\n")
  df_obj <- get(df_name)  # get the dataframe
  
  cat(index,": Currently processing dataset: ",df_name,"\n")
  cat("Dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  cat("\n")
  num_miss <- nrow(df_obj[is.na(df_obj[["FORM_DATE"]]),])
  cat("NUmber of observations missing in FORM_DATE: ",num_miss, "\n")
  
  
  df_obj <- merge(df_obj,sorted_ppdat3,by=c("SYSIND","FORM_DATE"))
  
  cat("\n")
  cat("After adding visit index, dataset dimension: ","\n")
  info(df_obj,"SYSIND")
  
  ## change dataset name
  newdfname <- paste0("wVisitIndex_",df_name)
  assign(newdfname, df_obj)
  
  index = index + 1
}
```


```{r}
## Finally, we add visit index to the last two datasets: ALZ_LOAD_COG and CONSENSUS_DX
sorted_ppdat3 <- sorted_ppdat2 %>%
  select(SYSIND,EXAM_DATE,Visit_Index) %>%
  distinct()

cat("======================================================================","\n")
df_obj <- ALZ_LOAD_COG  # get the dataframe
df_name <- "ALZ_LOAD_COG"
cat(index,": Currently processing dataset: ",df_name,"\n")
cat("Dataset dimension: ","\n")
info(df_obj,"SYSIND")

cat("\n")
num_miss <- nrow(df_obj[is.na(df_obj[["INTERVIEW_DATE"]]),])
cat("NUmber of observations missing in INTERVIEW_DATE: ",num_miss, "\n")
  
df_obj <- merge(df_obj,sorted_ppdat3,by.x=c("SYSIND","INTERVIEW_DATE"),by.y = c("SYSIND","EXAM_DATE"))

cat("\n")
cat("After adding visit index, dataset dimension: ","\n")
info(df_obj,"SYSIND")
## change dataset name
newdfname <- paste0("wVisitIndex_",df_name)
assign(newdfname, df_obj)
index = index + 1

cat("======================================================================","\n")

for (df_name in c("CONSENSUS_DX_1", "CONSENSUS_DX_2", "CONSENSUS_DX_3")) {
  cat("======================================================================","\n")
  df_obj <- get(df_name)  # get the dataframe
  
  cat(index, ": Currently processing dataset: ", df_name, "\n")
  cat("Dataset dimension: ", "\n")
  info(df_obj, "SYSIND")
  
  cat("\n")
  num_miss <- nrow(df_obj[is.na(df_obj[["DATE_DX"]]), ])
  cat("NUmber of observations missing in DATE_DX: ", num_miss, "\n")
  
  df_obj <- merge(
    df_obj,
    sorted_ppdat3,
    by.x = c("SYSIND", "DATE_DX"),
    by.y = c("SYSIND", "EXAM_DATE")
  )
  
  cat("\n")
  cat("After adding visit index, dataset dimension: ", "\n")
  info(df_obj, "SYSIND")
  ## change dataset name
  newdfname <- paste0("wVisitIndex_", df_name)
  assign(newdfname, df_obj)
  index = index + 1
}

```

<br>


## Duplicates Detection by SYSIND and Visit_Index
```{r,results='asis'}
df_names <- ls(pattern = "^wVisitIndex_")
length(df_names)

df_names_wDuplicates <- c()

for (df_name in df_names) {
  df <- get(df_name)
  df <- df %>%
    dplyr::group_by(SYSIND, Visit_Index) %>%
    dplyr::filter(n() > 1)
  
  if (nrow(df) > 0) {
    df_names_wDuplicates <- c(df_names_wDuplicates, df_name)
    print( htmltools::tagList(DT::datatable(df,caption=df_name)))
  }
}

cat("Datasets with duplicates after grouping by SYSIND and Visit_Index: ",
    "\n")
print(df_names_wDuplicates)

```

<br>
<br>

## Duplicates Handling Per Dataset

### AAAD_GERIAT

```{r DH-1}
## list all the duplicates
tmp <- wVisitIndex_AAAD_GERIAT %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  dplyr::filter(n() > 1)

DT::datatable(tmp)
```



```{r DH-2}
## those two visits are quite close, I don't have a preference, I am just going to randomly pick the first observation
cat("Before removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_AAAD_GERIAT,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_AAAD_GERIAT,"SYSIND")

wVisitIndex_AAAD_GERIAT <- wVisitIndex_AAAD_GERIAT %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  slice(1)

cat("After removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_AAAD_GERIAT,"SYSIND","Visit_Index"),"\n")
info(wVisitIndex_AAAD_GERIAT,"SYSIND")
```

<br>

### ALZ_CLINICALSUM

```{r DH-3}
## list all the duplicates
tmp <- wVisitIndex_ALZ_CLINICALSUM %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  dplyr::filter(n() > 1)

DT::datatable(tmp)
```


```{r DH-4}
## after checking these two observations, all info in first observation were included in the second one, so I decided to remove the first obs since it got more missingness

cat("Before removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_ALZ_CLINICALSUM,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_ALZ_CLINICALSUM,"SYSIND")

wVisitIndex_ALZ_CLINICALSUM <- wVisitIndex_ALZ_CLINICALSUM %>%
   filter(!(SYSIND == 11220743 & FORM_DATE == as.Date("2020-05-20")))

cat("After removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_ALZ_CLINICALSUM,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_ALZ_CLINICALSUM,"SYSIND")
```


<br>

### ALZ_CSDD

```{r DH-5}
## list all the duplicates
tmp <- wVisitIndex_ALZ_CSDD %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  dplyr::filter(n() > 1)

DT::datatable(tmp)
```

```{r DH-6}
## I dont have a preference for this person as well....
## I think I will pick the first one, since it got the NOTES_MEDS information

cat("Before removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_ALZ_CSDD,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_ALZ_CSDD,"SYSIND")

wVisitIndex_ALZ_CSDD <- wVisitIndex_ALZ_CSDD %>%
   filter(!(SYSIND == 11008433 & EXAM_DATE == as.Date("2019-02-22")))

cat("After removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_ALZ_CSDD,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_ALZ_CSDD,"SYSIND")

```

<br>

### ALZ_NEURO_CDR

```{r DH-7}
## list all the duplicates
tmp <- wVisitIndex_ALZ_NEURO_CDR %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::select(SYSIND,EXAM_DATE,Visit_Index,everything())

DT::datatable(tmp)
```

```{r DH-8}

table(wVisitIndex_ALZ_NEURO_CDR$METHOD)
## IP: in-person; TE: Telephone; MR: Medical Records

## There are 5 out of 1102 individuals with duplicate records. Some duplicates occurred because multiple methods were used to retrieve the CDR information. Instead of pivoting the entire dataset to a wider format, I think a better approach is to retain only one observation for those individuals. The priority order should be: IP > TE.

cat("Before removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_ALZ_NEURO_CDR,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_ALZ_NEURO_CDR,"SYSIND")

## for 11005393: remove the obs obtained on 2019-02-05	
wVisitIndex_ALZ_NEURO_CDR <- wVisitIndex_ALZ_NEURO_CDR %>%
   filter(!(SYSIND == 11005393 & EXAM_DATE == as.Date("2019-02-05")))

## for 11008433: remove the obs obtained on 2019-02-22
wVisitIndex_ALZ_NEURO_CDR <- wVisitIndex_ALZ_NEURO_CDR %>%
   filter(!(SYSIND == 11008433 & EXAM_DATE == as.Date("2019-02-22")))

## for 11009423: both obs were obtained through TE, I decided to keep the obs with CDR_COMM, so obs obtained on 2019-10-23 should be removed
wVisitIndex_ALZ_NEURO_CDR <- wVisitIndex_ALZ_NEURO_CDR %>%
   filter(!(SYSIND == 11009423 & EXAM_DATE == as.Date("2019-10-23")))

## for 11161523: both obs were obtained through IP, no solid reason, but I prefer keep the second obs, so I will remove the one on 2022-03-02
wVisitIndex_ALZ_NEURO_CDR <- wVisitIndex_ALZ_NEURO_CDR %>%
   filter(!(SYSIND == 11161523 & EXAM_DATE == as.Date("2022-03-02")))

## for 11221433: remove the TE obs obatined on 2020-01-15
wVisitIndex_ALZ_NEURO_CDR <- wVisitIndex_ALZ_NEURO_CDR %>%
   filter(!(SYSIND == 11221433 & EXAM_DATE == as.Date("2020-01-15")))

cat("After removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_ALZ_NEURO_CDR,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_ALZ_NEURO_CDR,"SYSIND")
```

<br>

### CONSENSUS_DX_1
```{r DH-9}
## list all the duplicates
tmp <- wVisitIndex_CONSENSUS_DX_1 %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::select(SYSIND,DATE_DX,Visit_Index,everything())

DT::datatable(tmp)
```
```{r DH-10}
## I dont exactly know which obs to choose, for now, I will select the first obs for both individuals, later, if needed to be changed, I can modify then

cat("Before removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_CONSENSUS_DX_1,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_CONSENSUS_DX_1,"SYSIND")

wVisitIndex_CONSENSUS_DX_1 <- wVisitIndex_CONSENSUS_DX_1 %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  slice(1)

cat("After removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_CONSENSUS_DX_1,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_CONSENSUS_DX_1,"SYSIND")
```


<br>

### MEDICAL_HIST
```{r DH-11}
## list all the duplicates
tmp <- wVisitIndex_MEDICAL_HIST %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  dplyr::filter(n() > 1) %>%
  dplyr::select(SYSIND,EXAM_DATE,Visit_Index,everything())

DT::datatable(tmp)
```


```{r DH-12}
## same as above, no preference can be made for those people.
## I will just randomly pick the first obs
cat("Before removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_MEDICAL_HIST,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_MEDICAL_HIST,"SYSIND")

wVisitIndex_MEDICAL_HIST <- wVisitIndex_MEDICAL_HIST %>%
  dplyr::group_by(SYSIND, Visit_Index) %>%
  slice(1)

cat("After removing duplucates: SYSIND * Visit_Index is ",dupFixCheck(wVisitIndex_MEDICAL_HIST,"SYSIND","Visit_Index"),"\n")

info(wVisitIndex_MEDICAL_HIST,"SYSIND")
```
<br>
<br>

## Common Columns Detection
```{r CCD-1}
## add suffix to some very common columns

cols_to_suffix <- c("EXAM_DATE", "EXAMINER", "AGE_AT_EXAM", "REVIEW_DATE", "REVIEWER","COMMENTS","FILLED_OUT_BY","NOTES","FORM_DATE","MEMORY")

for (df_name in df_names) {
  df_obj <- get(df_name)
  
  # find intersection of existing columns
  cols_exist <- intersect(cols_to_suffix, names(df_obj))
  
  if (length(cols_exist) > 0) {
    
    suffix <- sub("^wVisitIndex_", "", df_name)
    
    names(df_obj)[names(df_obj) %in% cols_exist] <-
      paste0(names(df_obj)[names(df_obj) %in% cols_exist],"_",suffix)
  }
  
  assign(df_name, df_obj, envir = .GlobalEnv) 
}

```


```{r CCD-2}
## add suffix to datasets: wVisitIndex_CONSENSUS_DX_1, wVisitIndex_CONSENSUS_DX_2, wVisitIndex_CONSENSUS_DX_3
cols_to_suffix <- setdiff(names(wVisitIndex_CONSENSUS_DX_1),c("REVIEW_DATE_wVisitIndex_CONSENSUS_DX_1","REVIEWER_wVisitIndex_CONSENSUS_DX_1","COMMENTS_wVisitIndex_CONSENSUS_DX_1","SYSIND","Visit_Index"))

for (df_name in c("wVisitIndex_CONSENSUS_DX_1","wVisitIndex_CONSENSUS_DX_2","wVisitIndex_CONSENSUS_DX_3")) {
  df_obj <- get(df_name)
  
  # find intersection of existing columns
  cols_exist <- intersect(cols_to_suffix, names(df_obj))
  
  if (length(cols_exist) > 0) {
    
    suffix <- paste0(str_split(df_name,"_")[[1]][2],"_",str_split(df_name,"_")[[1]][4])
    
    names(df_obj)[names(df_obj) %in% cols_exist] <-
      paste0(names(df_obj)[names(df_obj) %in% cols_exist],"_",suffix)
  }
  
  assign(df_name, df_obj, envir = .GlobalEnv) 
}

```


```{r CCD-3}
commonColsDetect(df_names)
```

<br>

### MEDCON_RC & AAAD_MEDCON

```{r CCD-4}
## I will just add suffix to both dataset
common_cols_handle("wVisitIndex_MEDCON_RC","wVisitIndex_AAAD_MEDCON","MEDCON_RC","AAAD_MEDCON")
```

<br>

### B5_NPIQ_RC & ALZ_NPIQ_CBRS

```{r CCD-5}
common_cols_handle("wVisitIndex_B5_NPIQ_RC","wVisitIndex_ALZ_NPIQ_CBRS","B5_NPIQ_RC","ALZ_NPIQ_CBRS")

```

<br>

### ALZ_SCREENING_RC & ALZ_SCREENING

```{r CCD-6}
common_cols_handle("wVisitIndex_ALZ_SCREENING_RC","wVisitIndex_ALZ_SCREENING","ALZ_SCREENING_RC","ALZ_SCREENING")
```

<br>

### B6_GDS_RC & AAAD_GERIAT
```{r CCD-7}
common_cols_handle("wVisitIndex_B6_GDS_RC","wVisitIndex_AAAD_GERIAT","B6_GDS_RC","AAAD_GERIAT")
```

<br>

### ALZ_EXAM & AAAD_MEDCON
```{r CCD-8}
common_cols_handle("wVisitIndex_ALZ_EXAM","wVisitIndex_AAAD_MEDCON","ALZ_EXAM","AAAD_MEDCON")
```

<br>

### BCFCI_RC & BCFCD_RC
```{r CCD-9}
common_cols_handle("wVisitIndex_BCFCI_RC","wVisitIndex_BCFCD_RC","BCFCI_RC","BCFCD_RC")
```

<br>

### MEDICAL_HIST & ALZ_CSDD

```{r CCD-10}
common_cols_handle("wVisitIndex_MEDICAL_HIST","wVisitIndex_ALZ_CSDD","MEDICAL_HIST","ALZ_CSDD")
```

```{r CCD-11}
## double check common columns before merging
commonColsDetect(df_names)
```

<br>
<br>

# Merge

## Label Columns for All Datasets

```{r final-merge-1}
for (dfname in df_names) {
  df <- get(dfname, envir = .GlobalEnv)  # adjust envir if needed

  for (col in names(df)) {
    Hmisc::label(df[[col]]) <- dfname
  }

  assign(dfname, df, envir = .GlobalEnv) # write back to the same env
}

```


<br>

## Merge All Dataset
```{r final-merge-2}
merged <- get(df_names[1])
cat("=======================================================================","\n")
cat("Before merging: Info of ",df_names[1],":","\n")
info(merged,"SYSIND")
cat("\n")
  
for (dfname in df_names[2:length(df_names)]) {
  merged <- merge_with_info(
    df1name = "merged",
    df2name = dfname,
    merge_cols = c("SYSIND", "Visit_Index"),
    info_col = "SYSIND"
  )
}
```

<br>

## Add the Info Cols Back
```{r}
merged <- merge(df_common_cols,merged,by="SYSIND",all.y = T)
info(merged,"SYSIND")
```

<br>

## Reorder the Columns
```{r final-merge-3}
merged <- merged %>% 
  select(SYSIND, Visit_Index,everything()) %>%
  arrange(SYSIND,Visit_Index)

```

<br>

Save Finalized Merged Dataset
```{r}
## save rds
saveRDS(merged,paste0(out_directory,"PRADI_June2025_Cleaned.rds"))
```

